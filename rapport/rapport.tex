\documentclass[a4paper,oneside, draft]{memoir}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

% bedre orddeling Gør at der som minimum skal blive to tegn på linien ved
% orddeling og minimum flyttes to tegn ned på næste linie. Desværre er værdien
% anvendt af babel »12«, hvilket kan give orddelingen »h-vor«.
\renewcommand{\englishhyphenmins}{22} 

\usepackage{colortbl}  % Bruges til at farve celler, rækker mv. i tabeller
\usepackage{pdflscape} % Gør landscape-environmentet tilgængeligt
\usepackage{fixme}     % Indsæt "fixme" noter i drafts.
\usepackage{hyperref}  % Indsæter links (interne og eksterne) i PDF


\renewcommand{\ttdefault}{pcr} % Bedre typewriter font
%\usepackage[sc]{mathpazo}     % Palatino font
\renewcommand{\rmdefault}{ugm} % Garamond
%\usepackage[garamond]{mathdesign}

%\overfullrule=5pt
%\setsecnumdepth{part}
\setcounter{secnumdepth}{-1} % Sæt overskriftsnummereringsdybde. Disable = -1.

\newcommand{\EDSL}{EDSL (Embedded Domain Specific Language) \renewcommand{\EDSL}{ EDSL }}

\title{Controlling embedded devices with funktional reactive programming}

\author{Martin Dybdal (dybber@dybber.dk), \\
Jesper Reenberg (jesper.reenberg@gmail.com) \\ og
Troels Henriksen (athas@sigkill.dk)}

\date{\today}
\pagestyle{plain}



\begin{document}
\maketitle

\begin{abstract}
  Robots are conventionally programmed in low-level imperative
  languages with no concepts like events, synchronicity or any of the
  advantages found in functional programming languages (like pattern
  matching). Reactive programming languages embedded in Haskell, like
  Frob \cite{frob99} and Yampa \cite{arrowsrobotsfrp02}, has been
  suggested for robot programming, but they require a complete Haskell
  runtime system, which is to large to fit on more
  resource-constrained devices. We tie these two ends together,
  creating a highly declarative language for robot programming using a
  staged-compilation strategy like the one found in Flask
  \cite{flask08}, that makes it possible to run programs on devices
  with few resources. In the creation we've used the Flask-codebase as
  a starting point and huge parts of the code is left unchanged.
\end{abstract}


\section{Disposition}
\begin{itemize}
\item Abstract

\item Preface
  \begin{itemize}
  \item Brief intro to robot programming
    \begin{itemize}
     \item Sensors and Actuators
    \end{itemize}
  \item Brief Arduino introduction
  \item Brief Flask introduction
    \begin{itemize}
     \item The staged compilation strategy
    \end{itemize}
  \end{itemize}

\item Previous Work
  \begin{itemize}
  \item Frob
  \item Esterel
    (http://www.softwaresafety.net/Esterel.org/esterel.html)
  \item Lustre \cite{lustre91}
  \item Flask
  \end{itemize}

\item "`Our system"'
  \begin{itemize}
  \item Staged compilation
  \item Dataflows
  \item Node representation
  \item Devices
  \item Interrupts
  \item Events
  \end{itemize}

\item Example programs

\item Conclusions

\item Bibliography

\item Appendixes
  \begin{itemize}
  \item A Flask tour
  \item Small guide to Arduino and electronics
  \end{itemize}
\end{itemize}  

\bibliographystyle{plain}
\bibliography{rapport}

\appendix

\chapter{Small guide to Arduino and electronics}

\begin{quotation}
  Arduino is an open-source electronics prototyping platform based on
  flexible, easy-to-use hardware and software. It's intended for
  artists, designers, hobbyists, and anyone interested in creating
  interactive objects or environments.

  Arduino can sense the environment by receiving input from a variety
  of sensors and can affect its surroundings by controlling lights,
  motors, and other actuators. The microcontroller on the board is
  programmed using the Arduino programming language (based on Wiring)
  and the Arduino development environment (based on
  Processing). Arduino projects can be stand-alone or they can
  communicate with software on running on a computer (e.g. Flash,
  Processing, MaxMSP).
\end{quotation}

\fixme{This is citet from Arduinos homepage the 28. of April 2009 at 15:16}

\fixme{<<Image of our Duemilanove>>}

There are different kinds of Arduino boards. All are based on
different ATmega* processors from Atmel. The older boards used serial
communication while the newer ones are connected to the computer
through a USB cable, but still using the same serial communication
protocol (i.e. serial through USB). The USB cable also serves as a
power supply.


We will describe the Arduino Duemilanove board we have used, in the
sections that follow, but most information will apply to
the other Arduino boards as well.

\section{Pins}
The Arduino board can connect to several external components through
diverse input and output pins. The pins are split in three sections on
the board \textit{power}, \textit{analog in} and
\textit{digital}. Before any IO can happen on a pin, it's mode must be
set. The mode of a pin defines if it is to be used to read input or
write output. The mode is set by the function \texttt{void pinMode(int
  pinnumber, int mode)} where \textit{pinnumber} is a number between
0-5 for analog and 0-13 for digital and \textit{mode} is either
\texttt{OUTPUT} or \texttt{INPUT}.

\subsection{Power pins}
\begin{itemize}
\item Reset: Resets the board when connected to ground. \fixme{tror jeg i
    hvert fald..}
\item 3V3: Constant 3,3v output
\item 5v: Constant 5v output
\item Gnd: Ground
\item Gnd: Ground
\item Vin: External power supply connection (9v recomented)
\end{itemize}

\subsection{Digital pins}
There are 14 digital input and output pins from which 6 of them can be
used to generate analog output by PWM (Pulse Width Modulation). It's
possible to read a boolean value \texttt{HIGH} and \texttt{LOW} by the
following function \texttt{bool digitalRead(int pinnumber)} where
pinnumber is a number between 0 and 13. It's possible to write a
boolean value by the following function \texttt{void digitalWrite(int
  pinnumber, int value)} where pinnumber is a number between 0 and 13
and value is either \texttt{HIGH} or \texttt{LOW}.

\subsection{Analog input}
There are 6 analog input pins. It's possible to read a voltage level
from each of them using the function \texttt{int analogRead(int
  pinnumber)} where \textit{pinnumber} is a number between 0 and 5
indicating which pin to read from. The result is given as an integer
in the range from 0 to 1023. It's possible to write a voltage level
(PWM wave, explained below) by the following function \texttt{void
  analogWrite(int pinnumber, int value)} where \textit{pinnumber} is
one of (3,5,6,9,10,11) which is located among the digital pins and
\textit{value} is an integer in the range from 0 to 255.

\subsubsection{PWM}
The reason why the 6 analog output pins is located among the 14 digital
pins is that the platform uses PWM to generate the desired voltage level.

\section{Timers}
The ATmega168/ATmega328 processors has three different hardware
timers. One of them is used by arduino software to provide a
\texttt{millis()} function that gives us the amount of milliseconds
since the timer started and a \texttt{delay} function that actively
holds the processor occupied for a given time period.

\fixme{...which are 8 bit and 16 bit timers. Interference problems with the
PWM output pins.}

\section{Electronics}
\fixme{Maybe a little refresher on electronics (e.g. how each
  component are drawn in a diagram, if we are going to use diagrams in
  the article). }

\end{document}
