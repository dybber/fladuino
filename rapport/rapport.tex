\documentclass[a4paper, oneside, final]{memoir}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

% bedre orddeling Gør at der som minimum skal blive to tegn på linien ved
% orddeling og minimum flyttes to tegn ned på næste linie. Desværre er værdien
% anvendt af babel »12«, hvilket kan give orddelingen »h-vor«.
\renewcommand{\englishhyphenmins}{22} 

% Fix of fancyref to work with memoir. Makes references look
% nice. Redefines memoir \fref and \Fref to \refer and \Refer.
% \usepackage{refer}             %
% As we dont really have any use for \fref and \Fref we just undefine what
% memoir defined them as, so fancyref can define what it wants.
\let\fref\undefined
\let\Fref\undefined
\usepackage{fancyref} % Better reference. 

\usepackage{colortbl}  % Bruges til at farve celler, rækker mv. i tabeller
\usepackage{pdflscape} % Gør landscape-environmentet tilgængeligt
\usepackage[draft]{fixme}     % Indsæt "fixme" noter i drafts.
\usepackage{hyperref}  % Indsæter links (interne og eksterne) i PDF

\usepackage[format=hang]{caption,subfig}
\usepackage{graphicx}
\usepackage{stmaryrd}
\usepackage{amssymb}
\usepackage{listings}

\renewcommand{\ttdefault}{pcr} % Bedre typewriter font
%\usepackage[sc]{mathpazo}     % Palatino font
\renewcommand{\rmdefault}{ugm} % Garamond
%\usepackage[garamond]{mathdesign}

%\overfullrule=5pt
%\setsecnumdepth{part}
\setcounter{secnumdepth}{1} % Sæt overskriftsnummereringsdybde. Disable = -1.
\chapterstyle{hangnum} % changes style of chapters, to look nice.

\makeatletter
\newenvironment{nonfloatingfigure}{
  \vskip\intextsep
  \def\@captype{figure}
  }{
  \vskip\intextsep
}

\newenvironment{nonfloatingtable}{
  \vskip\intextsep
  \def\@captype{table}
  }{
  \vskip\intextsep
}

\makeatother


\newcommand{\EDSL}{EDSL (Embedded Domain Specific Language) \renewcommand{\EDSL}{ EDSL }}

\title{Controlling embedded devices with functional reactive programming}

\author{Martin Dybdal (dybber@dybber.dk), \\
Jesper Reenberg (jesper.reenberg@gmail.com) \\ og
Troels Henriksen (athas@sigkill.dk)}

\date{\today}
\pagestyle{plain}

\begin{document}

\frontmatter

\maketitle
\thispagestyle{empty}

\begin{abstract}
  Circuits with embedded processors are conventionally programmed in
  low-level imperative languages with no concepts like events,
  synchronicity or any of the advantages found in functional
  programming languages (like pattern matching). Reactive programming
  languages embedded in Haskell, like Frob \cite{frob99} and Yampa
  \cite{arrowsrobotsfrp02}, has been suggested for programming these
  systems, but they require a complete Haskell runtime system, which
  is too large to fit on more resource-constrained devices.

  We tie these two ends together, creating a highly declarative
  language for programming resource scarce embedded processor using a
  staged compilation-strategy like the one found in Flask
  \cite{flask08}, where code native to the hardware-platform is
  generated from a data flow graph and this code is then compiled to
  machine-code by a platform-specific compiler.

  In the creation we've used the Flask-codebase as a starting point
  and huge (isolated) parts of the code is left unchanged. Our
  contribution includes functionality suitable for the domain of
  control systems where the connected hardware devices (e.g. sensors,
  motors or displays) can differ much. Specifically we include a
  framework for specifying interfaces to these peripherals, primitives
  for event-handling and (\ldots).
\end{abstract}

\clearpage 
\chapter*{Preface}
This report is a 15 ECTS Bachelor project at the Computer Science
Department (DIKU), University of Copenhagen. The authors are Martin
Dybdal, Troels Henriksen and Jesper Reenberg. The project is
supervised by Ken Friis Larsen, assistant professor at DIKU.

\fixme{maybe add thanks to Flask-guys}

\clearpage

\tableofcontents*

\mainmatter

\fixme{remove all uses of "`very"'}
\fixme{change bibtex style to one that includes URL's in the generated list,
  such as plain-url or another fancy one.}
\fixme{change $\backslash$ url to use the hyperref package so real links are
  used.}
\fixme{check all quoted text for use of the same quotes!!!!}
\fixme{Check all cites. Should there be a space between the word and cite or
  not.}
\fixme{Check all refs. Should be converted to vref to utilize the varioref package}

\chapter*{Disposition}
\begin{itemize}
\item Abstract

\item Preface 

\item Introduction
  \begin{itemize}
  \item Brief intro to robot programming
    \begin{itemize}
     \item Sensors and Actuators
    \end{itemize}
  \item Brief Arduino introduction
  \item Brief Flask introduction
    \begin{itemize}
     \item The staged compilation strategy
    \end{itemize}
  \end{itemize}

\item Related Work
  \begin{itemize}
  \item Frob
  \item Esterel
    (http://www.softwaresafety.net/Esterel.org/esterel.html)
  \item Lustre \cite{lustre91}
  \item Flask
  \end{itemize}

\item "`Our system"'
  \begin{itemize}
  \item Staged compilation
  \item Dataflows
  \item Node representation
  \item Devices
  \item Interrupts
  \item Events
  \end{itemize}

\item Example programs

\item Conclusions

\item Bibliography

\item Appendixes
  \begin{itemize}
  \item A Flask tour
  \item Small guide to Arduino and electronics
  \end{itemize}
\end{itemize}  


\chapter{Introduction}

\section{Problem statement}
In this report we want to present our robot programming framework
\textit{Fladuino}. Fladuino is an adaption of the sensor network
framework \textit{Flask} for the robot domain.

Flask is a domain specific language embedded in Haskell for writing
sensor network code. With Haskell functioning as a meta-language. The
final result of executing a Flask program is generated code in a
sensor network language. And our framework Fladuino follows exactly
the same concepts as Flask though it generates C-code written
specifically for our robots.

In the following chapters we want to argue that taking our outset from
Flask has been successful. Both in the sense that Flask was easily
adaptable and in the sense that our result, Fladuino, is sufficient
for many tasks in robot programming.

It is the prevailing conception that robots has some sort of
autonomous behavior. A simpler definition, says that a robot is any
programmable electronic system that is equipped with sensors and
actuators. The second definition is more general, in that it applies
to almost any programmable electronic system, and the autonomous
behavior will often be achieved programmatically. 

Our goal with Fladuino is to provide a framework that facilitates
robot programming, but such a framework also has to provide features
for programming the kind of input-output systems which doesn't
necessarily have any autonomous behavior. So there are actually two
steps: making a library suitable for programming sensors, actuators
and connecting them, and secondly facilitate programming autonomous
robots.

Robots are reactive systems. We've found the best description of what
distinguishes a reactive system in Zhanyong Wan's PhD
thesis ``Functional Reactive Programming for Real-Time reactive
systems'' \cite{Chambers1992}.  As he explains we can
partition computer systems into:
\begin{itemize}
\item Transitional systems, that takes some data as input, does some
  computation on it and delivers some resulting output (an example of this
  is a compiler).
\item Interactive systems, where the state of the program switches
  from computation to getting more input and back (a text editor is an
  example).
\item Reactive systems that continuously has to respond to
  environmental changes. Often reactive systems has to do with our
  physical environment, either simulating it (e.g. a computer game) or
  is required to respond to its changes (e.g. a robot).
\end{itemize}

A reactive programming language is a language with primitives for connecting
processes (a kind of ever-changing input values, often called signals). 

\section{Hardware platform}
The choice of hardware-platform has an influence on how to design such a
language. We've chosen to make our language and framework target the
Arduino-platform \cite{arduino}.  

The term ``Arduino'' is somewhat ambiguous.  It is both a registered
trademark of the Arduino team that can be used by licensed
manufacturers, a line of platforms based on various Atmel AVR
microcontrollers, as well as a general term for any device that is
mostly compatible with the official Arduino microcontroller boards.
This paper will use the latter meaning unless otherwise is explicitly
mentioned.  We will use the term ``an Arduino board'' to refer to the
physical package of microcontroller and I/O ports.

There are number of reasons for why we think this platform is a good
choice. First of all, our institute DIKU was planning on buying a
couple of these boards for research in Human Centered Computing about
interactive-objects and when they heard we were interested in creating
a framework for robot development they finally bought some and let us
use them. Even better reasons is that they are cheap (approximately
200 DKK for an Arduino Duemilanove, at the time of writing) and is
easily extensible. E.g. you can buy extensions for ethernet,
bluetooth, or even small touchscreens. Finally, the Arduino comes with
a relatively high-level C-interface, sparing us from most low-level
programming and bit trickery.

We have only had resources to test our work on the Arduino
Duemilanove\footnote{\url{http://www.arduino.cc/en/Main/ArduinoBoardDuemilanove}},
Arduino BT\footnote{\url{http://www.arduino.cc/en/Guide/ArduinoBT}},
Arduino
Mega\footnote{\url{http://arduino.cc/en/Main/ArduinoBoardMega}}, and
Pololu 3pi\footnote{\url{http://www.pololu.com/catalog/product/975}}.

\section{Motivation}
Robots has been used in the industry for decades, replacing humans in
repetitive tasks like sewing, assembling and transportation. In the
last years, robots have been introduced to the consumer market,
e.g. the Roomba vacuum cleaner. This is quite probably a sign that
robots are getting cheaper and affordable for more tasks. In the future
we will probably see robots deployed in many other uses. But falling
hardware prices is not everything, efficient development and
prototyping of robot control programs is another aspect in making
robots affordable. \fixme{code reusability}

\section{Structure outline}
In the following section (chapter \ref{chapter:Flask}) we will go
through the existing Flask system. Its design and how you use it to
write sensor-network programs. 

In chapter \ref{chapter:design} we will look at what is needed when
programming robots that isn't already in Flask and how this should be
done (i.e. the core design decisions).

In chapter \ref{chapter:implementation} we will talk about the
technically modification we have made to transform Flask to Fladuino.

In chapter \ref{chapter:evaluation} we will make an evaluation on
Fladuino. With a discussion of benefits and disadvantages of our
strategy, pros and cons.

\chapter{Flask}
\label{chapter:Flask}

Flask is a domain specific language embedded in Haskell for
programming sensor networks. Flask is based on the idea of
constructing \textit{dataflow graphs} that express the overall flow of
data in the program. The basic task in writing a Flask program is thus
to connect (or \textit{wire}) incoming streams of sensor data to
outgoing streams of data (e.g. to other nodes in the network) with
some eventual data processing in between. A program thus takes form of
a directed acyclic graph.

On figure \ref{ewma-example} we show an example of a dataflow graph
taken from the paper "`Flask: A Language for Data-driven Sensor
Network Programs"'. The graph represents a program for detecting earth
quakes with two exponentially weighted moving averages (EWMA) of the
seismometer values.

\begin{nonfloatingfigure}
\label{ewma-example}
  \includegraphics[width=0.9\textwidth]{images/flask-ewma}
  \centering
  \caption{Flask dataflow graph}
\end{nonfloatingfigure}

Later we will examine how this is written in Flask, but looking at it
we see that this is a single connected graph\footnote{This is actually
  two different \textit{atomic subgraphs} because of the posting wire
  required to use the sensor, but for simplicity we wont discuss this
  now. Refer to \cite{flask06} or our section on posting wires,
  \ref{sec:posting wires}.}. Many Flask programs will though consist
of several \textit{atomic subgraphs}. That they are atomic means that
when we start to execute it (when it receives an input value), we have
to run it to completion before we can go on to the next action. This
point is actually easier to explain when talking about Fladuino. The
good example here is that we might want two different \textit{atomic
  subgraphs} to execute depending on whether a button on our circuit
was pushed or released.

\section{From Flask to sensor network-code}
A fundamental thing in Flask is its compilation and
execution-strategy. A Flask program is a description of the prior
mentioned dataflow-graph written in Haskell, using specialised
Haskell operators (dataflow-operators, stream-combinators,
stream-operators or signal-functions) for connecting and
manipulating the streams. Some of the these stream-operators also
accepts some node-level code which should be inserted into the
dataflow. This node-level code is written in one of several
object-languages (where Haskell is the meta-language) for
manipulating node-level values.

When compiling the Haskell program description of the dataflow graph,
you end up with an executable that generates and outputs code in a
sensor network language called NesC\footnote{NesC is an extension to
  C, with some additional constructs suitable for low-level sensor
  network programming for TinyOS.}.

The generated NesC code can then be translated by an ordinary
NesC compiler to machine code running on the nodes in the
sensor network.  Thus, when you write a Flask-program, you use
ordinary Haskell constructs to manipulate which NesC-code should
ultimately be generated.

\begin{nonfloatingfigure}
  \includegraphics[width=0.9\textwidth]{images/flask-simple}
  \centering
  \caption{High-level illustration of the Flask compilation strategy.}
\end{nonfloatingfigure}

Flask provides two object-languages: NesC and Red. Having NesC as an
object-language, allows the user to write all programs that's expressible in
NesC. The other language Red, is described below.

Both languages are integrated into Flask using the GHC quasiquotation
library \cite{quasiquote07}, written by the author of Flask, Geoffrey
Mainland. The quasiquotation facility allows you to write the object
languages in their original syntax inside the Flask/Haskell
environment, as well as allowing you to intersperse generation time
variables (which results in compile time constants) into
object-language code.

Figure \ref{fig:mainloop} illustrates this, showing a simplified
version of the main loop and initialisation code from Fladuino.
\texttt{cdefs\_toc} and \texttt{cstms\_toc} are compile-time values
(lists of C statements). And \texttt{\$edecls} and
\texttt{\$stms} are anti-quoters which job is two put the values into
the correct position in the C syntax tree at generation-time.

\begin{figure}
\begin{verbatim}
[$cunit|
$edecls:cdefs_toc

void setup()
{
    $stms:cstms_toc
}

void loop()
{
    if (event_available()) {
        handle_event(pop_event());
    }
}
|]
\end{verbatim}
\caption{Simplified version of the Fladuino main-loop and
  initialization code}
\label{fig:mainloop}
\end{figure}

\section{Red --- a restricted node-level language}
\label{sec:red}
Red is an object-language from Flask that allows you to write concise
node-level mapping functions, like predicates or conversion functions
for simple tasks, without having to deal with NesC. It takes it syntax
from Haskell, but is restricted to a small subset of what is
normally expressible in Haskell. The reason for disallowing these
things are the same as for not compiling Haskell directly to the
sensor nodes in the first place: the existing Haskell runtimes are too
large to fit on the limited memory of a sensor node. Therefore we can't
allow uses of features that e.g.  requires a garbage collector. Flask
disallows the following Haskell 98-features (with probably some more,
that we have overlooked) from Red:
\begin{itemize}
\item Recursive functions
\item Recursive datatypes
\item Curried functions (except for a few simple cases)
\item Higher-order functions
\item Type classes
\item Laziness
\item Modules
\end{itemize}

And only a very small subset of the Standard Prelude is included
in Flask.

Figure \ref{fig:redqq} is an example of a quasiquoted function in Red,
which determines whether a ratio between two values is below a certain
compile-time determined threshold. 
\begin{nonfloatingfigure}
\begin{verbatim}
[$exp|\(hi, lo) -> hi / lo > $flo:threshold|]
\end{verbatim}
  \caption{Example of quasiquoted Red function}
  \label{fig:redqq}
\end{nonfloatingfigure}


\section{Streams, node-level values and dataflow-operators}
Expressing dataflow graphs in Haskell is often done using the
Arrows library. But this isn't a strategy that fits Flask, as
Arrows requires that an arbitrary Haskell function can be lifted to a
signal function. This isn't possible here, because Flask signal
functions are meant for being executed on the sensor nodes and
therefore aren't Haskell functions, but instead a representation of
the node-level code that should be generated. Flask instead defines
some of the same operators as in the Arrows library, though with
different type signatures. It therefore feels like you can use the
Arrows library without really using it, but you won't get the special
Arrow syntax.

In Flask a stream of type $\alpha$ values has the type \texttt{S
  $\alpha$}. The arguably simplest way to generate such a stream is
the \texttt{clock :: Int -> S ()} Flask-function, which given a time
interval in milliseconds generates a unit signal on the resulting
stream. \texttt{clock 1000} is signalling every second. This isn't
useful by itself, we need to do something with this signal, e.g. do
some data processing. As mentioned before, Flask provides a set of
stream operators for that.


\subsection{\texttt{Reify} and \texttt{LiftN}}
To explain the stream operators we need to discuss the two type
classes: Reify and LiftN.  Instances of the Reify type classes are
Haskell types that has node-level equivalents. An instance has to
provide a function reify that given a Haskell value returns a
representation of its node-level type.

LiftN is a multi parameter type class\footnote{This requires the GHC
  language extension MultiParamTypeClasses}. \texttt{LiftN eta
  Integer} represents that the Haskell value of type can be lifted
to a node-level \textit{Integer}.\\

\noindent
Now to one of the Flask stream operators, \texttt{sfilter}. Its type
signature is:

\begin{verbatim}
sfilter :: forall a eta . (Reify a, LiftN eta (a -> Bool))
              => eta -> S a -> S a
\end{verbatim}

Thus the stream operator \texttt{sfilter} takes a node-level predicate
as the first argument (type eta), and returns a signal function
(\texttt{S a -> S a}) that for each input value uses the predicate to
decide whether it should be passed on to its output stream or not.


\subsection{Streamoperators}
Now we will list a description of most of the stream-operators and
signal functions that Flask provides. \fixme{Add type signatures and
  improve explanations}
\begin{description}
\item
\begin{verbatim}
sconst :: forall a b eta. (Reify b, LiftN eta a)
       => eta -> S b -> S a
\end{verbatim}
     Maps all values on the input-stream to a constant (node-level) output value.

\item $\ggg$ \hfill \\ Connects a stream with a stream operator.
  E.g. \texttt{clock 10 $\ggg$ sconst (liftN [\$exp|42|])} is a stream
  of 42 values, that is passed on every 10th millisecond.


\item 
\begin{verbatim}
szip, (&&&) :: forall a b . (Reify a, Reify b)
      => S a -> S b -> S (a, b)
\end{verbatim}
  This operator has two input-streams. It waits for a value on both
  inputs, constructs a pair of them, and sends this pair to its
  output-stream.

\item 
\begin{verbatim}
sunzip :: (Reify a, Reify b) => S (a, b) -> (S a, S b)
\end{verbatim}
  The inverse of \texttt{\&\&\&} and \texttt{szip}, which splits a
  stream of pairs into two individual output-streams.

\item 
\begin{verbatim}
smap :: forall eta a b . (Reify a, Reify b, LiftN eta (a -> b))
     => eta -> S a -> S b
\end{verbatim}
  Maps a node-level function over all stream-values, creating a stream
  of the resulting output-values.

\begin{verbatim}
sintegrate  ::  forall a b c eta . (Reify a, Reify b, Reify c,
                                    LiftN eta ((a, c) -> (b, c)))
            =>  N c ->  eta ->  S a ->  S b
\end{verbatim}
  When supplied with an initial (node-level) state value and a
  node-level function that takes the current state and the next value
  on the input stream, returning a new state and the next value to be
  send through to the output stream.

\begin{verbatim}
clock :: Int -> S ()
\end{verbatim}
  Creates a stream of unit-values
  that is fired with the given interval (specified in milliseconds).

\begin{verbatim}
sfilter :: forall a eta . (Reify a, LiftN eta (a -> Bool))
        => eta -> S a -> S a
\end{verbatim}
  Only propagates values through to the
  output-stream that satisfies a given node-level predicate.
  
\begin{verbatim}
smerge :: forall a . Reify a
       => S a -> S a -> S a
\end{verbatim}
Takes two input streams of the same type. When it received a value on
either of the inputs it will propagate this value to its output, thus
merging the streams into a single stream.

\end{description}


The data-flow graph from figure \ref{ewma-example} can now be written in Flask like below:
\begin{verbatim}
detect :: Double -> Double -> Double -> 
          S Double -> S (Double, Double)
detect low high threshold = 
   ewma high &&& ewma low
   >>>
   sfilter [$exp|\(hi, lo) -> hi / lo > $flo:threshold|]
\end{verbatim}


\chapter{Design of the Fladuino system}
\label{chapter:design}
Fladuino is a modification of Flask that can be used to program
Arduino devices in a functional reactive manner. In this chapter we
will analyse which requirements we need to set and which design
choices should be made.

A summary of the most important requirements for our system follows:

\begin{itemize}
\item It must be possible to define interfaces to external devices
  connected to an Arduino board, without having to modify Fladuino
  itself.  Interaction with these devices must take place through the
  same statically typed stream operator (and event) interface as any
  built-in part of Fladuino.
\item It must be possible to define simple variations on Arduino
  boards in terms of I/O-pin availability and custom capabilities,
  without having to modify Fladuino itself.  Implementing support for
  platforms that differ significantly from our built-ins (for example,
  using a different microcontroller) will not be possible without
  modifying the Fladuino libraries themselves, however.
\item We want to statically analyse and validate the program for
  certain classes of type and logic errors.
\item Fladuino must be able to generate a valid C-program suitable for
  running on an Arduino from a description of a dataflow graph. This
  graph must be expressed in the form of a Haskell program.
  \textit{This requirement stems from the platform selection (see
    section ...
    \fixme{ref til introduktion}) of Arduino and from the above
    requirement of mirroring Flask.}
\end{itemize}

And we set the scope of our project as follows:
\begin{itemize}
\item The design of Fladuino must mirror similar core design choices
  in Flask.
\item It is not required that we attempt to handle all error
  conditions.  We accept that hardware constraints pose certain hard
  restrictions (such as memory limits, integer counter overflow and
  CPU time starvation), and declare that writing a program with
  Fladuino that exceeds these constraints will result in information
  loss or undefined behaviour.  We shall, however, endeavour to design
  Fladuino so as to reduce the likelihood of these errors.
\item We won't add primitives for programming real time systems.
\end{itemize}

\section{Design foundations}

This section will summarise the basic structure of Fladuino, its
terms, and the constraints under which the design was formed.

\subsection{Terminology and basic \textit{modus operandi}}

As in Flask, Fladuino is implemented as a set of Haskell modules that
provides facilities for expressing the structure and behaviour of a
\textit{dataflow graph}, connecting \textit{dataflow operators}
through value-carrying directed graph edges (\textit{wires}).
\fixme{The following should be described in the Flask chapter} The
programmer writes a Haskell program, called the \textit{generator
  program}, or just the \textit{program}.  We shall refer to the
compilation of the program as \textit{compile-time}, and execution of
the program as \textit{generation-time}.  At generation-time, the
output will be a program source file suitable for further compilation
with the Arduino tools, but these are not part of the Fladuino system.
Generation-time may also terminate erroneously if the program
contains static errors: in this case, an error message with a
description of the problem will be printed.  Only errors that are
violations of the Haskell type system can be caught at compile-time,
and while we have attempted to structure the facilities provided by
Fladuino such that invalid programs will contain type errors, this
cannot be done for all error classes.  When the generator program is
run, it constructs a typed dataflow graph.  However, the types and
connections in the graph cannot be known in advance (they may be
determined programmatically, perhaps even by user input), hence we may
signal type errors at generation time if the wiring of stream
operators violate type-safety.  We do, of course, supply Haskell
operators operating on stream representations with assigned static
types, that guarantee the type-validity of the resulting graph, but
certain sophisticated applications of Fladuino may desire more
flexibility than permitted by these.  This is notably the case when
the structure of the graph is a function of a value not known until
generation-time (and thus can't possibly be checked by the Haskell
compiler at compile-time).

It is intended that all static errors are caught at compile- or
generation-time; in particular that Fladuino will never generate
malformed C.  This guarantee does not extend to C code manually
included or integrated by the user, of course.

\subsection{Hardware constraints}

While we do not use ``Arduino'' to refer to any specific hardware
configuration, implementations of our target platform still share some
fundamental characteristics that have influenced many design choices
and tradeoffs in Fladuino.  In particular, the low amount of available
main memory, and the comparatively large amount of available flash
memory for program code, suggests that we optimise for low memory
usage over low code size.  Indeed, as we shall see in
\ref{sec:dataflowtranslation}, we have opted to directly express much of
the control flow in the code itself, where a typical program, with
plenty of available memory, might instead opt a more data-driven
approach.  This choice was also made in Flask itself, and as
\cite{flask08} observes, such static dataflow is not a problem for a
large class of applications.  Additionally, we recover much of the
lost flexibility through programmatic wiring of the dataflow graph at
generation-time.

\section{Structural overview}

Fladuino consists of several interconnected parts combined to form a
domain-specific language embedded in Haskell.\footnote{We do however
  make heavy use of Glasgow Haskell language extensions, such as
  multi-parameter typeclasses and existential types, so Fladuino will
  not run in a standard implementation of Haskell 98.}  As in Flask,
this takes the form of providing facilities to express the structure
of a \textit{dataflow graph}, connecting \textit{dataflow operators}
through directed graph edges (\textit{wires}).  Conceptually, these
parts can be divided into the following:

\begin{itemize}
\item Haskell operators and functions used to describe the dataflow
  graph have been defined.  It is not intended that these are
  exclusively used to construct the program, but rather that they are
  part of a larger Haskell program.  Since a Fladuino program is
  highly static at run-time, the generating program should be written
  to support easy configuration and modification.
\item A compiler is supplied for the Haskell-like programming language
  Red (see section \ref{sec:red}), which is used to tailor the
  behaviour of stream operators.
\item A \textit{stream generator} that takes a description of a
  dataflow graph and generates object code (in the case of Fladuino,
  C).
\item The \textit{Fladuino runtime system}, consisting of code written
  in C implementing the runtime facilities used by the generated code.
  The most notable part of the runtime system is the event loop and
  its supporting machinery, which is the subject of
  \Fref{sec:dataflowevaluationstrategy}.
\item A module that encapsulates the hardware facilities offered by
  the target platform and provides the ability to check whether the
  requirements made by the users program can be fulfilled.  Arduino is
  a highly variable hardware platform, no more than a simple
  microcontroller connected to a basic extensible circuit board, and
  no assumptions can be made about which electrical components the
  user might need to control.  Therefore we provide a comprehensive
  facility for expressing device interaction in a high-level fashion,
  and automatically check whether any of these interactions are
  incompatible, or violate basic hardware restrictions.  For example,
  we might check that the program does not try to interact with a
  pushbutton connected to a hardware pin that does not support
  interrupts, or that the program does not express both a
  potentiometer and diode connected to the same pin.\footnote{Of
    course, it must be mentioned that we cannot possibly check that
    the hardware has actually been set up in the way described by the
    program --- we can only check for internal consistency and
    violations of basic hardware restrictions, not whether the
    programs model of the device actually corresponds with reality.}

  Furthermore, since there are several different boards under the
  Arduino name, all with slightly different capabilities, we permit
  selection of the exact Arduino variant targeted by the program.

  Finally, since Arduino is a fundamentally extensible platform, we
  provide facilities for implementing \textit{drivers} for entirely
  new devices, such that use of these is also automatically
  sanity-checked.
\end{itemize}

Except for the last module, this structure has been adopted from
Flask.  Additionally, Flask defines additional facilities (such as
\textit{Flows} for communicating between sensor nodes) that build
heavily upon the TinyOS-platform for sensor networks, a platform that
is not available to us.  We have thus not adapted all of these
facilities in our work.  Posting wires, however, (see
\Fref{sec:posting wires}) have their own novel implementation in
Fladuino.

\section{Dataflow evaluation strategy}
\label{sec:dataflowevaluationstrategy}
As in Flask, the dataflow graph is divided into \textit{atomic
  subgraphs} consisting of a set of nodes connected by normal wires.
Evaluating such a subgraph consists of supplying a value on the input
wire, retrieving any values that may show up on output wires, then
setting up to evaluate any of the successor atomic subgraphs with
these values (see \ref{sec:dataflowtranslation} for the implementation
details).  The notion of an atomic subgraph serves the purpose of
dividing the dataflow graph into parts that can be evaluated
atomically without blocking.  Translating a dataflow graph into object
code is referred to as \textit{stream generation}.  Translating an
atomic subgraph is relatively straightforward, and the subject of
\Fref{sec:dataflowtranslation}, while it is far more interesting to
contemplate the question of what to do with the asynchronous events
that are the heart of reactive programming.  Indeed, we have to
analyse the constraints of our target platform(s) in order to reach an
adequate solution.  Since events are fundamentally connected to the
concept of a hardware interrupt (though we do not reject the ability
for sinks to manually signal events), we cannot at any time predict,
or control, their arrival.

The simplest strategy would be to, upon arrival of an event via an
asynchronous hardware-level interrupt, immediately evaluate all atomic
subgraphs that have nodes listening to the event.  However, this
approach is unacceptable for several reasons:

\begin{itemize}
\item If we are already in the progress of computing an atomic
  subgraph $s_1$ already, we will have to store information about the
  computation while we evaluate all graphs $s_n$ listening to the
  newly arrived event.  The size of this information can be
  significant, especially if we receive yet another event while
  evaluating one of $s_n$.  There is no upper bound on the number of
  events we can be forced to handle within each other, and the storage
  spent on saving the state of each computation can be significant on
  such memory-constrained devices as the Arduino platform.
\item Doing large computations (in space or time) within interrupt
  handlers is generally a bad idea.  Not only are additional
  interrupts disabled while running the handler (and making them
  re-entrant is nontrivial), but the already running code may already
  tie up an arbitrary amount of the memory resources.  As a result,
  interrupt handlers should ideally terminate swiftly and use few
  resources, which cannot be guaranteed for evaluation of arbitrary
  atomic subgraphs.
\item Most importantly, the subgraph computation already in progress
  may be in a critical section, and we cannot guarantee that the
  subgraphs to be evaluated in response to the event will not overlap
  with this critical section.  Thus, we can end up with interleaved
  access to explicit state (memory contents) as well as implicit state
  (output).  This violates one of the basic tenets of atomic
  subgraphs, namely atomicity of computation.
\end{itemize}

As a result, our basic program evaluation is as follows.  We shall
maintain an ordered \textit{event queue}, each element containing
information about an atomic subgraph (actually, an entry node to the
subgraph) that should be called, as well as the input value that
caused the input wire to fire.  The generated program consists of a
loop that continuously checks for the presence of an element in the
queue, and if so, removes it and computes the subgraph indicated by
it.  Hardware interrupts are handled by checking all events that may
be signalled by the given interrupt (the details of this check are
defined individually by each type of event), and if the check is
positive, an element is added to the event queue requesting the
evaluation of all listeners of that event.  It is important that the
event-check, as well as the computation of the value of the event, is
done in the interrupt handler itself, as the value may depend on the
hardware state (such as the voltage on an input pin) as of that
moment, and it cannot be guaranteed that this state will not have
changed by the time the main loop retrieves the element from the event
queue.  This means that we cannot provide any strict guarantees about
the resource usage of interrupt handlers, but this is a hardware issue
that is fundamentally unsolvable in software.  Optimisations can be
performed, of course, but ultimately there are constraints on how much
any computer can do.

\begin{figure}
\label{fig:eventloopcode}
\begin{verbatim}
repeat forever
  if (event_available())
    handle_event(pop_event())
  endif
endrepeat
\end{verbatim}
\caption{Pseudocode for the event loop}
\end{figure}

\subsection{Idle waiters}

For many embedded applications, a typical workflow would be to
continuously poll an input source (such as a sensor), then adjusting
some output device based on the reading.  For example, a
line-following robot may take readings from its light sensors, then
adjust its servo-motors to ensure that it is following the line
straightly.  This can be done by simply attaching a node to a clock
that fires every millisecond, but this approach has a notable
disadvantage if many other events are being received at the same time.
The event queue may become filled with a large amount of clock events,
thus drowning out (and losing) potentially more interesting events.
In most cases, it is not a problem that the continuous polling of the
input source is in irregular intervals, but the silent loss of events
such as button presses is normally undesirable.

Thus, we provide the notion of \textit{idle waiters}, a list of atomic
subgraphs that are evaluated in a round-robin fashion whenever the
event queue is empty.  They are a useful facility for specifying
computations that should be done whenever the program is not busy with
something else.

\subsection{Posting wires}
\label{sec:posting wires}
In the dataflow graph, atomic subgraphs can be connected by
\textit{posting wires}.  These serve to temporarily suspend execution
while the system waits for external response, thus serving in place of
blocking operations (which are not permitted in atomic subgraphs).
Conceptually, when a posting wire is encountered during evaluation of
the graph, it will send a request to an external hardware unit, wait
for a response, and then fire the destination node with the value of
the response as the input value.  Posting wires are therefore a
natural fit for solving the problem of sensor-requests that can
involve waiting an indeterminate time for the response.  For clarity,
in the following we shall refer to the external device as the
\textit{sensor}, the node preceding the posting wire as the
\textit{input node} and the node following the posting wire as the
\textit{output node}.  The phrase \textit{send a request to the
  sensor} denotes the act of requesting data from the sensor under the
assumption that a reply will be received.  Note that ``output node''
is a lossless abstraction, as several nodes may be on the receiving
end of the posting wire.  A fundamental simplifying assumption we make
in the following section is that the structure of the sensor request
is a function only of the identity of the posting wire, and is notably
not based on the value that arrived at the input node.  This rule,
which is also present in Flask, grants us much more leeway in the
implementation of posting wires.

It is not intuitively obvious what to do when a posting wire is
reached a second time, before a response has come back from the
previously sent request.  Several options present themselves:

\begin{description}
\item[Accumulate-Repeat:] If we are already waiting for a response
  from the sensor for the posting wire when a value arrives at the
  input node, we will not send another request.  Instead, we will
  increase an internal counter, and upon receiving the sensor
  response, fire the output node a number of times equivalent to the
  number of times a value arrived at the input node.  See
  \Fref{fig:accum-repeat} for a visualisation.
\item[Queue:] When a value arrives, queue a request to the sensor.  We
  cannot assume that all sensor hardware supports a request queue (in
  fact, we can be fairly certain that most will not), so we have to
  maintain this queue in the Fladuino runtime system.  Whenever a
  response comes back from the sensor, we fire the output node and
  check whether there are any requests left in the queue.  If so, we
  send it.  As the format of a request is a function of only the
  posting wire itself, not the incoming value, such a queue could be
  implemented as a mere integral counter, thus ignoring the problem of
  dynamically allocating memory (and potential problems resulting from
  such, as described in section \ref{sec:event_queue}).  See
  \Fref{fig:queue} for a visualisation.
\item[Ignore:] We can also opt not to queue or accumulate anything,
  ignore any input values sent while there is already an outstanding
  request, and fire the output node a single time upon receiving a
  reply from the sensor.  While appearing to be a lossy hack at first
  glance, we argue that it is in fact the most elegant solution, that
  its deficiencies are not important in the typical case, and that
  they can (to a degree) be worked around, if necessary.
\end{description}

\begin{figure}
  \label{fig:accum-repeat}
  \includegraphics[width=\textwidth]{images/accumulate-repeat-1}
  \includegraphics[width=\textwidth]{images/accumulate-repeat-2}
  \includegraphics[width=\textwidth]{images/accumulate-repeat-3}
  \caption{Visualisation of Accumulate-Repeat}
  \centering
\end{figure}

\begin{figure}
  \label{fig:queue}
  \includegraphics[width=\textwidth]{images/queue-1}
  \includegraphics[width=\textwidth]{images/queue-2}
  \includegraphics[width=\textwidth]{images/queue-3}
  \caption{Visualisation of Queue}
  \centering
\end{figure}

Both the \textit{Accumulate-Repeat} and \textit{Queue}-strategies
suffer from \textit{clogging-propagation}, where the multitude of
inputs, greater than the sensor is capable of handling, will also
result in a large amount of activity on the output side of the posting
wire.  Especially Accumulate-Repeat suffers badly, as the receiving of
a sensor-reply will result in a potentially large amount of work, a
situation that can result in information loss if the event queue fills
up.  And as each firing of the output node will be with the same
value, it is in practice often unlikely that the repeated evaluations
are appreciably different from just a single evaluation.

The Queue strategy is more appealing, having the attractive property
that every input eventually results in a sensor request and a value
sent to the output node (barring hardware failure or --- unlikely ---
integer counter overflow).  The chief disadvantage is that there is no
way to stop the execution of the queue, should it outlast the
necessity for sensor requests.  A brief flurry of input values might
translate into requests being sent to the sensor long after desirable.
Recall that a sensor request may not necessarily translate to a
harmless, passive reading, but can be everything between reading a
simple light sensor to transmitting a sonar pulse and detecting the
environmental echo.  The Ignore strategy only causes consecutive
requests to be sent to the sensor if the input node keeps receiving
input.  Thus, a posting wire can be considered an abstraction that is
activated as long as it keeps receiving input values, and outputs a
continuous stream of sensor readings as long as it is activated.

\subsubsection{Simulating Accumulate-Repeat and Queue with Ignore}

Should the behaviour exhibited by the Accumulate-Repeat and
Queue-strategies truly be necessary for some application, we will
show that it is possible to mostly simulate their behaviour via the
Ignore strategy.  We shall not delve into the gory technical details
(such as the error handling necessary to avoid fragility), but
merely show the structure of the solution.

For Accumulate-Repeat, we can connect both input and output nodes to
an \textit{accumulator node} that distinguishes between its two
inputs.  When receiving a value from the input node, an internal
counter will be increased by one.  When receiving a value (the sensor
reading) from the output node, the value will be packaged up with the
counter into a tuple and sent to successors of the accumulator node,
after which the counter will then be reset to zero.  Said successors
will be the nodes that would normally follow the output node.  This
does not in itself implement the ``repeat''-portion of
Accumulate-Repeat, but we have removed the loss of information, and
can thus trivially take whatever action repeated firings of the output
node would have resulted in.

\begin{figure}
  \label{accum-repeat-with-ignore}
  \includegraphics[width=0.9\textwidth]{images/accum-repeat-with-ignore}
  \caption{Simulating Accumulate-Repeat}
  \centering
\end{figure}

Simulating the Queue behaviour is significantly more complicated and
requires a somewhat clumsy use of events (see
\ref{sec:events_design}).  Values received at the input-node are sent
on to a \textit{counter node}, where we check whether we are still
waiting for the sensor to reply to a previously sent request.  If so,
we increment an internal counter and send nothing further.  When the
reply is received, by being sent to the output node, we will send a
value to the counter node, telling it to send another request to the
sensor if the counter is nonzero.  The problem in this scheme is the
wire from the output node to the accumulator node --- this graph edge
would form a cycle, something that is expressly forbidden.  On figure
\ref{queue-with-ignore}, we solve this issue by an \textit{event node}
that listens to a discrete event broadcast by the output node (the
Fladuino event system is described in detail in
\Fref{sec:events_design}).  Using the event system in such a way is
technically feasible, but violates the spirit of the design.  The
connection from output to event node can be considered to be a
particularly weak kind of posting wire --- informally, they are to
real posting wires, as software interrupts are to hardware interrupts.

\begin{figure}
  \label{queue-with-ignore}
  \includegraphics[width=0.9\textwidth]{images/queue-with-ignore}
  \caption{Simulating Queue}
  \centering
\end{figure}

\section{Representing peripherals}
Arduino is a flexible system for general embedded development, with no
specific application in mind.  The Arduino platform can therefore be
connected to a diverse amount of peripheral devices, all with their
own specific functionality and programming interface.  It is thus
natural to support this diversity as a core concept of Fladuino; not
(solely) as a library of drivers for various devices, but rather as a
framework and set of tools provided to the programmer so that Fladuino
can be extended to transparently support the devices he has need of.
For demonstration, we have \fixme{not really done yet} written a
framework for programming the Pololu 3pi robot and the peripherals
connected to it (electromotors, sensors, buttons, etc.).

Furthermore, Arduino is a broad term encompassing a range of
more-or-less compatible platforms, though each of them differ slightly
in their exact capacity.  Apart from variations in such things as
memory size, they differ in amount and capability of their I/O pins.
This latter diversity is what we are most concerned with in Fladuino,
as we would like to statically check (at generation-time) the
hardware assumptions expressed in the program.  Thus, we also provide
a facility for describing the exact capabilities of a specific
Arduino-based platform, and provide default descriptions of common
Arduino-compatible such as the Arduino Duemilanove, Arduino Mega,
Arduino BT, and Pololu 3pi.

Defining the driver for each external component consist of a general
device specification in the form of a Haskell type definition, a set
of functions operating on the device type and possibly a set of event
specifications, provided the device can supports the notion of events.

\fixme{find a good example to add here}

\subsection{Platforms}
\label{capabilities}
A platform is defined by a list of \textit{logical pins}, and
free-form \textit{capabilities}, the latter being a set of strings
describing the identity or unusual qualities of the platform.  For
example, the platform definition for the Pololu 3pi robot contains a
``3pi''-capability that exists merely to express the fact that the
platform supports the quirks of the 3pi robot that cannot be expressed
through a list of pins.  Any device intended to make use of these
quirks would explicitly require the presence of this capability.

\subsubsection{The Fladuino pin model}
\label{pins}
There is no concrete distinction between analog and digital pins in
the Atmel microcontroller that lies at the heart of all Arduino
platforms --- they are just subsets of the single set of numbered pins
that differ in their capabilities.  Arduino, however, drives a hard
distinction between analog input and general-purpose digital pins, in
particular enumerating them in different sequences (there is a digital
pin 0 distinct from analog pin 0).  This notion is fully integrated
and supported in Fladuino; in fact there is no way to directly address
pins by the name they are known by to the Atmel microcontroller.  We
identify three layers of pin abstraction, each building on the one
below it:

\begin{description}
\item[Arduino pins] are what a normal user of Arduino will be familiar
  with.  They are identified by a \textit{pin type} (digital or
  analog-input) and a number.  Analog-input pin 0 and digital pin 0
  are not the same pin.  This is the layer of abstraction that devices
  work at.
\item[Logical pins] are a simplification of Arduino pins, where the
  Arduino pin abstraction is mapped to a single enumerated sequence.
  This mapping is defined specifically for each platform; for example,
  Arduino digital pin 0 will equal logical pin 0 on both the
  Duemilanove and Mega platforms, but analog pin 0 equals logical pin
  14 and 54, respectively.  A typical user of Fladuino will never have
  to go below this level of abstraction, and will only have to
  interact with it if he is defining a new platform.
\item[Hardware pins] are the physical pins connected to the
  microcontroller.  They are only interacted with in the
  implementation of the Arduino and Fladuino supporting libraries.
  The Arduino libraries themselves define the mapping from logical to
  hardware pins, and adding a new mapping is a significant task.
\end{description}

This choice of abstraction is not as obvious as it may appear: some
measure of expressive power is lost by restricting ourselves to the
interface provided by Arduino, rather than permitting complete
exploitation of the capabilities of the microprocessor.  Yet for the
following reasons, we believe we made the right choice:

\begin{itemize}
\item The software abstraction provided by Arduino exposes a uniform
  interface to a range of different hardware implementations.  These
  implementations share a similar software interface to their shared
  functionality, thus making porting between them easy.  In contrast,
  not even pin numbers are necessarily identical between the
  microcontrollers found across the range of supported platforms.  We
  could solve this by defining our own mapping between abstract pins
  and hardware pins (based on the chosen platform), but we see no
  advantage to this approach over adopting the mapping already defined
  by Arduino.
\item A shared pin abstraction makes it easier for Fladuino-generated
  programs to use existing Arduino libraries.
\item The pin identifier sequences defined by the Atmel
  microcontrollers are not particularly intuitive when mapped to the
  physical layout of the Arduino boards.  They are fragmented and with
  large jumps.
\end{itemize}

Abstractions aside, each pin is not only defined by its number, but
also by a set of \textit{capabilities}, much like the ones that cover
the entire platform.  For example, a given pin may support such things
as \texttt{pin-change interrupts} (triggering an asynchronous signal
when the input value on the pin changes) or \texttt{pulse-width
  modulation} (analog output).  Many hardware devices only work when
attached to pins with special capabilities --- for example, a
push-button must be attached to a pin supporting interrupts --- and
the capability notion allows us to statically sanity-check any used
devices for such requirements at generation-time.

\subsection{Devices}
We use the term \textit{device} for any form of peripheral that can be
connected to an Arduino board, e.g. buttons, electromotors and
potentiometers.  The definition of a device consists of a list of
\textit{usages}, each describing a discrete reservation of some
hardware resource, and a unique identifier.  A device can be
parametric --- in fact, most are --- in for example the I/O pins that
it is attached to.  As a concrete example, the device describing a
plain digital output pin is parametric in the form of the single
integer parameter denoting the number of the digital pin it
represents.

The notion of a usage deserves further elaboration: apart from being a
facility for statically finding resource usage conflicts between
devices, they are also a way to configure the starting state of the
Arduino board.  We define three different kinds of usages, two of which
reserve exclusive access to the hardware resource that they refer to:

\begin{description}
\item[Digital pin usage] is an expression of exclusive access to one
  of the digital pins on the Arduino board.  If any other device has a
  usage involving the same pin, this will be reported as an error at
  generation-time.  A digital pin usage also specifies a list of
  capabilities that must be provided by the indicated pin.
  Additionally, a digital pin usage can have one of three types:
  \begin{description}
  \item[Digital output,] in which case the usage will also have to
    specify a starting value (\texttt{HIGH} or \texttt{LOW}) on the
    pin.
  \item[Digital input]
  \item[Analog output,] in which case a starting value must be
    specified in the range $[0,255]$.  Note that this ``analog'' value
    is, of course, implemented via PWM (see \ref{pwm}), and the
    capability ``PWM'' should thus be required of the pin.
  \end{description}
\item[Analog input pin usage] denotes exclusive access to a specified
  analog input pin.  The usage also specifies a list of capabilities
  that must be provided by the indicated pin.
\item[Capability requirement usage] is a dependency on the presence of
  a given \textit{platform capability} (see \ref{capabilities}).  In
  contrast to the pin usages, this dependency is not exclusive.
\end{description}

Some measure of power is lost by restricting devices to exclusive
access to pins.  However, the fragility of having devices share these
I/O pathways require detailed knowledge of exact device behaviour
anyway, in order to ensure that they will not be incompatible.  Given
this knowledge, the user can merely connect several physical devices
to the same IO pin (for example, multiple diodes to the same digital
output pin) and use a single logical device in the Fladuino program to
interact with them.  Indeed, this solution is mostly satisfactory, as
long as the devices are (almost) identical in their interface.

See \Fref{sec:pushbuttondef} for an example of how to define a device
via these abstractions.

\subsection{Events}
\label{sec:events_design}
A central aspect of any embedded system is responding to external,
asynchronous events.  The hardware feature enabling this functionality
--- asynchronous interrupts --- is primitive and hard to use, leading
us to define a high-level interface, closely interconnected with the
device abstraction, with which we can describe reactions to stimuli in
terms that are closer to the problem domain of the application.  In
the following, we distinguish between \textit{triggering an
  interrupt}, which is the hardware executing the interrupt handler,
and \textit{triggering an event}, which is Fladuino arranging for the
execution of any event listener operators with the event as the input
value.

All events have a static type and value, which is used to distinguish
between them at generation-time, and an event may carry a data
\textit{payload} at runtime.  A critical piece of static information,
that can be found in most (if not all) events, is the device that the
event is associated with.  In our exposes programming interface, all
events stem from external sources of input, and a given event is such
intrinsically linked to some specific device, though it is possible to
define events that are not connected to Arduino's notion of a logical
device --- for example, by hardcoding the I/O pins directly into the
implementation of the event.  ``Synthetic'' events, events that are
explicitly triggered by stream operators, are not conceptually
problematic (apart for the need to distinguish same-type events by
something else than an associated device), but for reasons of time,
Fladuino does not expose a programming interface for triggering them.
We believe that manually triggered events open some interesting new
possibilities (not the least of which is Turing--completeness for
dataflow programs), and we could not afford them the attention they
deserve without straying too far in scope from the topic of our
project.

In this section, we shall assume that all events are connected to
Fladuino's notion of a device.  Not all events have payloads (or
rather, some events have payloads of the information-less type
\textit{unit}): an event indicating the press of a pushbutton has no
payload, and contains no information apart from the static event value
itself (which indicates the exact button that was pressed), while an
event indicating that a piece of sensor hardware has finished taking a
reading may contain the reading data as the payload.

As an example, assume that $p_1$ is a pushbutton device connected to
digital pin 1, $d_2$ a diode connected to pin 2, and $\sigma(e,d)$ a
dataflow graph node that fires whenever the given device $d$ triggers
event $e$.  We can then construct a dataflow graph such as
$\sigma(pushdown,p_1) \rightarrow toggle(d_2)$, connecting the input
of pressing a button to the action of toggling the state of a diode.

In the definition of an event, a list of Arduino pins (see \ref{pins})
indicates which pin-change interrupts might trigger the event.
Additionally, two object-language functions are defined: a
\textit{predicate}, for checking whether a given pin-change interrupt
is actually should actually cause the event to trigger, and a
\textit{value function}, that calculates the payload (if any) of the
event.  This yields total control to the event implementor, at the
cost of having to check all events possibly triggerable by an
interrupt, whenever the interrupt is triggered.  This can potentially
be problematic: as mentioned above, it is highly undesirable to spend
too much time in an interrupt handler, but we cannot defer execution
of either predicate or value function, as the result of those may
depend on highly volatile dynamic state of the Arduino.  Indeed;
merely the minute delay between the triggering of the interrupt, and
the execution of a some predicate or value function, may change this
state.  On the upside, the time spent in the interrupt handlers will
have a static upper bound defined by the number of events used in the
program, thus making problems of this sort likely to appear during
initial testing, and not lay dormant until after deployment.  Of
course, this bound is dependent on the implementation of the
user-defined predicate and value functions --- if these have
unpredictable runtime behaviour (or worse: block), we cannot guarantee
anything.  See \Fref{sec:pushbuttondef} for example code.

Events initiate dataflow at nodes marked as \textit{listeners} for the
specific event.  Design-wise there is nothing that prevents these
listeners from being successors of other nodes in some atomic
subgraph, but have not been able to identify a general use for such a
structure during our work (though see \Fref{sec:postingwireimpl} for a
notable exception).  As a result, we generally consider an
event-listening node to have no way of firing except for the
triggering of one of the events that the node is listening for.  A
single node can listen to multiple different events (though again, we
have not been able to identify a practical need), as long as the
payloads are of the same type.

\section{Design of the runtime system}

Fladuino is not only a code-generator, it also contains a runtime
system that implements much of the complex behaviour that the
generated code expresses.  This runtime system not only has to respect
the constraints imposed by the Arduino hardware, but also run
sufficiently fast while implementing the facilities necessary for the
Fladuino-generated code.  We need several facilities apart from what
is provided by the Arduino libraries themselves:

\begin{itemize}
\item We must have a \textit{timer} capable of at least
  microsecond-precision in order to support programs that use the
  clock as an input source.  This precision has been adopted verbatim
  from Flask, as we see no reason to deviate.
\item An \textit{event queue} must be provided that supports the
  operations mentioned in \Fref{sec:dataflowevaluationstrategy}.
\item An \textit{interrupt abstraction} built on top of the
  microcontrollers own hardware interrupts.  The Arduino libraries own
  interrupt support is too restricted for our purposes, as it only
  supports a restricted number of I/O pins.  The microcontroller
  itself supports \textit{pin change interrupts} on a much larger
  selection of I/O-pins, but the programming interface is much more
  complicated.  Hence, our runtime system defines a convenient wrapper
  library.
\end{itemize}

\chapter{Implementation}
\label{chapter:implementation}

The essence of Fladuino can be condensed to a single, conceptually
simple problem: translate a high-level functional reactive program to
a form suitable for execution on the Arduino platform.  We have chosen
to stop a step short, and merely generate C code meant for further
compilation through an Arduino-specific compiler.  We have no need of
the additional power we would gain through generating our own machine
code, and the additional amount of work required would be significant.
Flask chooses the same approach, in that it produces NesC-code for
running on sensor motes, likely for the same reasons.

\section{Dataflow translation}
\label{sec:dataflowtranslation}
At their heart, both Flask and Fladuino-programs consist of an
acyclic dataflow graph.  A core part of the system (the \textit{stream
  generator}) involves the translation of this high-level description
of the passage of data into the procedural target environment.
Fladuino adopts Flask's implementation almost verbatim, the details of
which will be explained within this chapter.

As in Flask, the graph is divided into \textit{atomic subgraphs},
sections that can be executed without blocking.

\subsection{Translation of a simple dataflow graph}

A set of nodes (dataflow operators) connected by a set of directed
graph edges (wires) make up the entirety of the dataflow graph. Each
wire is associated with type information regarding the values that
will be passed along it.  Some dataflow operators have no predecessor
and exist solely as entry points for data (they can be triggered by
outside events, such as device or timer interrupts), while others have
no successors and function as data sinks.  It is required that the
graph is acyclic, something that is enforced by every operator being
uniquely identified by (among other things) its predecessor(s).  A
stream operator can have multiple distinct input, but only a single
output, though this output can be split so as to send the same output
value to any number of successors.

For every operator $o$ in the dataflow graph, a set of unary functions
$o\_in_n()$ and a unary function $o\_out()$ will be generated.  The
arrival of a value $v$ at $o$ will be implemented by a call
$o\_in_n(v)$, where the exact choice depends on the wiring of the
graph.  In the typical case, even when several wires leads to a single
stream operator, there will be only a single such $o\_in_n()$
function\footnote{In fact, multiple ``in'' functions are only
  necessary for operators such as \texttt{szip}, which works by
  waiting until it has received two values $x, y$ from its two direct
  predecessors, after which it sends them along to its successors as
  the tuple $(x,y)$ --- in this case, the two functions will need
  different types and semantics, as there it is not required that $x$
  and $y$ have the same type.}.  Depending on the specific semantics
of $o$, a value $v'\equiv f(v)$ (where $f()$ represents the
computation done by $o$) may be propagated to the successors of $o$.
In this case, $o\_in_n(v)$ will call $o\_out(v')$, the implementation
of which will feature the calls $\forall s \in S(o). s\_in(v')$, where
$S(o)$ is the set of all successors of $o$.

$o\_in()$ is generated directly by the implementation of the specific
dataflow operator, but $o\_out()$ is automatically created by Fladuino
during code generation.  The utility of this division is that the
implementation of a dataflow operator does not feature tedious
duplication of the value propagation machinery, yet as it is not
required that $o\_out()$ is called at all, each dataflow operator can
still make its own choice whether to propagate a value or not.

It is worth nothing that a value need not contain any information
apart from its existence; \texttt{()} is perfectly valid as a signal.

\subsection{Implementation of posting wires}
\label{sec:postingwireimpl}
We have opted to implement posting wires as a thin layer of
abstraction on top of events, with a unique event associated with each
posting wire (see \Fref{sec:definingevents} for how events are
defined).  Implementing posting wires as a separate subsystem offers
no advantages over an implementation via abstractions built on the
existing event-dispatch infrastructure.  When creating a posting wire
between two nodes, two additional pieces of information must be
provided: a node-level function $f$ of type \texttt{() -> ()} and the
\textit{response event}, the event that the sensor will trigger to
reply to the request.  The function $f$ is, as evident from its type
signature, highly impure, and is responsible for actually transmitting
the request to the sensor.  The intent is that a Device whose
interface involves posting wires will define its own, simpler-to-use
facility on top of our primitive posting wire functionality.

A posting wire does not exist as a special relation between nodes, as
far as Fladuino is concerned.  The bridging from input- to output-node
is accomplished by registering the output-node as an \textit{event
  listener} for the response event.  The input node will, when it
calls $f$, set an internal flag signifying that the wire is waiting
for a reply from the sensor.  When an event of the response event type
arrives, the output node will check this flag and ignore the event
unless it has been set (after which it will clear it).  This opens up
the interesting possibility of using ``common'' events with a posting
wire, understood as events that are not responses to previously sent
requests.  For example, it is possible to define a posting wire where
$f$ does nothing, and the event listener is the event sent by some
specific push-button when it is pressed.  The end result is a wire
that ``delays'' signals until an event has been received.

\subsection{On blocking and busywaiting}

\section{Implementation of the runtime system}

In this section we will describe the implementation of the
runtime-facilities used in the code generated by Fladuino.  It is
combined with the user-generated code at generation-time by
Fladuino.

\subsection{Implementation of the event queue}
\label{sec:event_queue}
The event queue itself is such a central cog in our event-pumping
machinery that it is worth paying great attention to its form.  It is
essentially just a double-ended queue, but as it turns out, the
textbook implementation of this data structure is undesirable in
Fladuino.  Normally, one would construct a double-ended queue as a
linked list or array\footnote{In Fladuino, we would use a linked list
  rather than an array, as reserving large contiguous blocks of memory
  on the heap will often not be feasible on the memory-constrained
  Arduino platform.}, requesting additional memory from the heap as
necessary, but this runs the risk of the event-queue ballooning to
great size, especially if the program has an input source that
constantly triggers new events every few milliseconds.  Since the
stack and heap share the same memory space, we would run the risk of a
collision, causing data corruption possibly severe enough to
completely crash the program (eg. if the procedure return address on
the topmost stack frame was modified).  While we could modify the
event queue to perform a check for imminent collision whenever an
element was about to be added (and if so, ignore the event), we cannot
do the same whenever we expand the program stack, so we would run the
risk of the stack growing across the event queue and corrupting its
data, causing great harm when the main loop gets around to processing
these now invalid elements.  In conclusion, we cannot permit the stack
to grow uncontrollably.  An additional problem with using dynamic
memory is the unpredictable runtime behaviour of \texttt{malloc()},
something that is undesirable in an interrupt handler, as described in
the preceding section.

The design of our event queue thus has the following constraints:

\begin{itemize}
\item There must be a limit on the amount of memory it can occupy.
\item It must not waste too much memory.
\item Adding an element must have a predictable (and low) runtime
  cost.
\end{itemize}

The third constraint also prevents us from being too clever for our
own good, and for example storing the event-queue in the EEPROM
available on all Arduino variants in order to avoid using the same
memory as the program stack.  While an interesting idea, EEPROM writes
require unacceptable multi-millisecond delays.

Thus, our event queue consists of a statically allocated
(compile-time fixed-size) array that is not too big, and in which
element insertions have hard real-time runtime guarantees.  If an
attempt is made to insert an element into a full event queue, the
result will be a silent failure.  This is a tradeoff: as mentioned in
a previous section, we have to accept that it is possible for the
Arduino to be swamped with more work per time unit (or asked to store
more data) than it is physically able to do.  All we can do is to
design Fladuino such that the fatal error conditions are rare, and the
most common error conditions are survivable.  Stack (or heap)
corruption will in most cases result in the complete malfunction of
the program, and are thus the least desirable error case.  In
Fladuino, use of the heap is limited (and in fact bounded by the
static maximum size of the event queue), and stack/heap corruption
will in practice only occur if the program is large enough to consume
all available memory with its stack.  The most common error case, on
the other hand, will be attempting to add an element to a full event
queue, resulting in a silent failure.  There are many cases where this
is not desirable, of course, but many reactive programs will not
experience catastrophic failure if they lose even important events,
such as button presses.  Still, we recognise that not all event loss
can be brushed aside as merely an unimportant UI deficiency, and
therefore we provide a facility, termed \textit{idle waiters}, meant
to reduce the average load on the event queue and reduce the risk of
filling it up.

\section{User-extensible abstractions with typeclasses}
As explained in earlier chapters, one of our main additions to Flask,
is the possibility of defining drivers for peripherals and defining
new event types.

\subsection{Defining new devices}
A device is primarily a collection of functions for interacting with
the device and a setup function for initializing the function on
start-up. But also a list of which other hardware ... that it uses and
blocks other devices from using. E.g. which hardware pins or timers
that it needs.

We need a way to represent these devices as values, i.e. a way of
referring to a specific device and store information about it. A
simple solution would be to implement the device as a \textit{Device}
datatype with a set of required fields (e.g. a list of
dependencies). But devices differ, many devices would require
additional fields, e.g. about their starting state and which hardware
pin the device is connected to. A second reason for why this isn't a
good idea, is that we wouldn't have a way of distinguishing devices on
their types. Our solution is thus that a driver-writer has to create a
new datatype for each device and declare it as an instance of our
\textit{Device} typeclass. We can thus identify all devices as any
type with an instance of this typeclass and specific devices can be
identified directly by their datatype. The state of our program is
extended with a list of these devices. The required values are shown
in figure \ref{device typeclass}.

\begin{nonfloatingfigure}
  \label{device typeclass}
  \begin{verbatim}
class (Eq a, Show a) => Device a where
    setupDevice :: MonadFladuino m => a -> m ()
    usages :: a -> [Usage]
    uniqueId :: a -> String
\end{verbatim}
\end{nonfloatingfigure}

Remark that all 3 values requires the device itself as a
parameter. This is because we can have more than one instance of each
device-type, and they differ only in the values stored in the
datatype-fields. These functions needs to know specifically which
instance of the device-type that is referred to.

The \texttt{setupDevice} function initializes the device, it is
executed the first time the device is used (i.e. when it is added to
our list of known devices). A common operation here is to add global C
state-variables or adding certain includes of required header-files.

\texttt{usages} is a list of which hardware-dependencies the device
has. We use this to make sure that user doesn't try to use two
incompatible devices (e.g. two devices that both needs access to the
same PWM output pin)

\texttt{uniqueId} is our way of comparing devices, we can't just make
them instances



\subsection{Defining new events}
\label{sec:definingevents}
\section{Something about arduino external interrupt handling}
\fixme{Lav rigtigt overskrift.}

The default behaviour of the Atmega chip platform when interrupts occur is that
the GIE (Global Interrupt Enable) bit\footnote{which is the L-bit in the SREG
  (Status Register)} is cleared and thus all interrupt are disabled. The GIE bit
is automatically set again when the IHF (Interrupt Handler Function) returns,
using the RETI instruction. The software running on the chip could however
enable the GIE bit when the IHF is called, thus allowing nested interrupts. If
interrupts triggers when GIE is disabled, their individual flag bits is set and
when GIE is enabled again those interrupts will trigger in the order the flags
is located in the registers, and not necessarily in the order the interrupts
happened. When GIE is disabled and the same interrupt happens multiple times,
only the first one set the flag and thus it is not possible to know how many
times the interrupt actually occurred \cite[Section 4.7 page 14]{atmel8p}

\subsection{Types of interrupts}

The Atmega chip support two types of interrupts. The sophisticated INT0..1 pins
and the simple PCI0..2 which controls the PCINT0..23 pins. The sophisticated
interrupts supports low level, logical change, falling edge and rising edge,
though Fladuino only supports the logical change on any of the interrupt
types. These interrupts are triggered if the INT0..1 bit is enabled in the
EIMSK (External Interrupt Mask) Register and the GIE bit is set.

The simple interrupts only support logical change and doesn't directly support
separate IHF's for each PCINT pins but only for each of the three PCI0..2. These
interrupts are triggered if the GIE bit is set, either of the PCIE0..2 bits is
enabled in the PCICR (Pin Change Interrupt Control Register) and any of the
PCINT0..7, PCINT8..14, PCINT16..23 bits respectively, is enabled in the
PCMSK0..2 (Pin Change Mask) register. As any logical change to any of the
PCINT0..7 pins will only trigger the PCI0 IHF, this function must then see which
of the enabled PCINT0..7 pins that has changed its value since last time, by
keeping a track of their state, and then trigger the defined IHF for each of the
changed pins and so fourth for all the PCI0..2. An example of this can be seen
on the Arduino Playerground
\footnote{\url{http://www.arduino.cc/playground/Main/PcInt}, last checked 23rd
  June 2009} which have been modified to work on all the supported platforms in
Fladuino system \cite[Section 10 page 70]{atmel8p}.

\chapter{Example programs}

\textit{Beskrivelse af vores fedeste eksempelprogrammer: 3pi,
  binærtæller etc. og hvorfor det er smart.}

\section{Building on the abstractions}

In the following sections different Haskell code is shown as examples of how
different Fladuino interfaces, which utilises various parts of framework such as
events, are constructed. For brevity, module imports has been omitted in all the
examples.

\subsection{Defining a pushbutton}
\label{sec:pushbuttondef}

The following is a definition of the Fladuino interface for a simple digital
pushbutton. First the type constructor \texttt{PushButton} is defined with the
data constructor \texttt{PushButton Integer} where the \texttt{Integer} type
defined which pin the physical device is connected to.

\begin{verbatim}
data PushButton = PushButton Integer
                  deriving (Eq, Show)
\end{verbatim}

\noindent
Then a \texttt{Device} instance declaration on \texttt{PushButton} is done which
registers the specified digital pin as being \texttt{DigitalInput} and requiring
interrupt functionality. This assures that the specific pin has interrupt
functionality and that no other devices using this pin requires
\texttt{DigitalOutput} otherwise an error will occur.

\begin{verbatim}
instance Device PushButton where
    usages (PushButton pin) = [DPinUsage pin ["interrupt"] DigitalInput]
\end{verbatim}

Since logical change interrupts occurs twice on a pushbutton (when pushed and
then when released) it is easy and god abstraction to define a
\texttt{PushButtonPressEvent} and a \texttt{PushButtonReleaseEvent}, and thus
the two type constructors is defined

\begin{verbatim}
data PushButtonPressEvent = PushButtonPressEvent PushButton
                            deriving (Eq, Show)
data PushButtonReleaseEvent = PushButtonReleaseEvent PushButton
                              deriving (Eq, Show)
\end{verbatim}

\noindent
Next a \texttt{Event} instance declaration on the two \texttt{PushButton} events
is needed. The \texttt{Event} type class needs definitions for the operations
\texttt{setupEvent} and \texttt{interruptPins} which are both self
explanatory. To distinguish these two events from each other, the value on the
pin associated with the physical pushbutton is read and if the value is
\texttt{HIGH} it is treated as a press event and if it is \texttt{LOW} it is
treated as release event.

\begin{verbatim}
instance Event PushButtonPressEvent () where
    setupEvent e@(PushButtonPressEvent (d@(PushButton pin))) = 
     do addDevice d
        pv <- statevar d "press_predicate" 
        let v = H.Var (mkName pv)
        addCImport pv [$ty|() -> Bool|] [$cexp|$id:pv|]
        addCFundef [$cedecl|int $id:pv () {
                              return (digitalRead($int:pin) == HIGH);
                            }|]
        return $ mkEvent e Nothing (Just v)
    interruptPins (PushButtonPressEvent (PushButton pin)) = [DPin pin]


instance Event PushButtonReleaseEvent () where
    setupEvent e@(PushButtonReleaseEvent (d@(PushButton pin))) = 
     do addDevice d 
        pv <- statevar d "rel_predicate" 
        let v = H.Var (mkName pv)
        addCImport pv [$ty|() -> Bool|] [$cexp|$id:pv|]
        addCFundef [$cedecl|int $id:pv () {
                              return (digitalRead($int:pin) == LOW);
                            }|]
        return $ mkEvent e Nothing (Just v)
    interruptPins (PushButtonReleaseEvent (PushButton pin)) = [DPin pin]
\end{verbatim}

With this definition, we can define programs such as

\begin{verbatim}
onEvent (PushButtonPressEvent $ PushButton 3) >>> (toggle $ diode 13 True)
\end{verbatim}

This program will toggle the state of a diode connected to digital pin
13 (a default device on almost all Arduino boards) whenever the
pushbutton attached to digital pin 3 is pressed.

\subsection{Defining a potentiometer}

A potentiometer interface can be defined in Fladuino quite easily as it doesn't
make any sense to define any events upon this as its value needs to be pulled
once in a vile to know if it has changed and/or to act upon that.

The \texttt{Device} instance declaration of \texttt{Potentiometer} defines that
it uses an Analog pin but with no functionality requirements.

\begin{verbatim}
data Potentiometer = Potentiometer Integer
                     deriving (Eq, Show)

instance Device Potentiometer where
    usages (Potentiometer pin) = [APinUsage pin []]

instance AnalogInputDevice Potentiometer where
    genReadCode (Potentiometer pin) resultvar = [[$cstm|$id:resultvar = analogRead($int:pin);|]]
\end{verbatim}

This allows programs such as

\begin{verbatim}
idle >>> (valueOf $ Potentiometer 0) >>> smap [$exp|(/4)|] >>> (setValue $ AnalogOutputPin 10 0)
\end{verbatim}

The reason why the pulled value is devided by 4 is that the Atmega chip by
default returns values between 0 and 1024 when doing analog reads but can only
write values between 0 and 256 unless explicitley changed. The mapping 0 to 1024
when reading analog values is from GND to AREF which is nomally 0v and 5v
respectively though AREF can be explicitley changed.

\subsection{Defining a battery reader for 3pi}

The Pololu 3pi robot has a few extra features that the Arduino boards
doesn't. One of these features is the possibility of reading how many millivolts
is left on the batteries that power the device. This feature can be used to
indicate if the batteries needs replacement, e.g. by signalling with the buzzer
or writing text to the display.

The \texttt{Drevice} instance definition \texttt{BatteryReader} requires that the
platform supply the functionality \textit{3pi battery reader} which is only
defined for the Pololu 3pi platform.

\begin{verbatim}
data BatteryReader = BatteryReader
                        deriving (Eq, Show)

instance Device BatteryReader where
    usages _ = [CapabilityRequired "3pi battery reader"]
    uniqueId _ = "3pi_battery_reader" -- there only need to be one

instance AnalogInputDevice BatteryReader where
    genReadCode _ resultvar = [[$cstm|$id:resultvar = read_battery_millivolts();|]]
\end{verbatim}


\subsection{Defining a new platform}

\subsection{Defining Saturn V-nozzle control}

\chapter{Evaluation}
\label{chapter:evaluation}

\begin{itemize}
\item Is this for any practical use?
\item What was easy and hard when writing the example-programs?
\item How does the example-programs compare to similar programs
  written directly in C? More or less code? More or less debugging?
\end{itemize}

\chapter{The Fladuino Future}
\textit{Hvad vi ikke har, eller hvad der skal arbejdes videre med. }

Lidt idéer:
\begin{itemize}
\item Find på noget bedre end Red 
\item Se om man kan få lavet en instans af Arrow-typeklassen, så man
  kan bruge Yampas Arrow-syntax.
\item Bedre fejlmeddelelser (Pt. udskrives syntaxtræet efter parse af
  quasiquotet tekst ved fejl. Dette skal dog rettes i
  Quasiquotation-modulet eller måske kræver det speciel integration
  med compileren)
\item \textit{(Bør vi måske satse på at få med inden aflevering:)}
  Gør det endnu nemmere at skrive drivers til nye
  robotter. F.eks. så man kun skal angive en typeklasse instans der
  foræller om robottens fysiske egenskaber (afstand mellem hjul etc.)
  og hvilke funktioner der skal kaldes for at styre hjulenes
  hastighed. Hvorefter man så får adgang til en række generelle
  styringsabstraktioner.

\item 3pi robotten er langt fra understøttet komplet. Fx er der lidt problemer
  mht. at 3pi robotten bruger alle timere til motor, motor, og sensor/buzzer
  etc. Fladuino går her ind og overskriver timeren til bl.a. buzzer og andet.

\item  Yderligere er der også problemer med det meste af 3pi platoformen, ikke
  er precist nok defineret., Fx hvilke pins der kun kan specielle ting.
\end{itemize}

\chapter{The past}
Discussion about related robot programming tools (Frob, Yampa, Atom,
Lustre, etc.).

\section{Partiel evaluation / specialisation} 
\fixme{reference to arne glenstrup}

\chapter{Conclusions}
\textit{Opsummering på hvad vi har opnået}

Ideas for this section:
\begin{itemize}
\item Modified Flask, so it generates Arduino targeting C-code.
\item Added abstractions for Events, Devices, Platform specification etc.
\item Written a small framework/driver-library for the 3pi.
\item Small note on example programs
\item Comparison with Frob, Atom etc.
\end{itemize}


\bibliographystyle{bibliography/theseurl}
\bibliography{bibliography/rapport}

\appendix

\chapter{Small guide to Arduino}

\fixme{We should update the $\backslash$ texttt to uses the listings
  inline formatting instead when ever c code is listed.}

Description of Arduino from the official
website\footnote{\url{http://www.arduino.cc/} downloaded the 28. of April 2009 at 15:16}:
\begin{quotation}
  Arduino is an open-source electronics prototyping platform based on
  flexible, easy-to-use hardware and software. It's intended for
  artists, designers, hobbyists, and anyone interested in creating
  interactive objects or environments.

  Arduino can sense the environment by receiving input from a variety
  of sensors and can affect its surroundings by controlling lights,
  motors, and other actuators. The microcontroller on the board is
  programmed using the Arduino programming language (based on Wiring)
  and the Arduino development environment (based on
  Processing). Arduino projects can be stand-alone or they can
  communicate with software on running on a computer (e.g. Flash,
  Processing, MaxMSP).
\end{quotation}

\begin{nonfloatingfigure}
  \centering
  \includegraphics[scale=0.5]{images/ArduinoDuemilanove}

  \caption{Picture of a Arduino Duemilanove. Picture is taken from the Arduino
    homepage: \url{http://arduino.cc/en/Main/ArduinoBoardDuemilanove}.}
  
\end{nonfloatingfigure}

There are different kinds of Arduino boards. All are based on
different ATmega processors from Atmel. The older boards used serial
communication while the newer ones are connected to the computer
through a USB cable, but still using the same serial communication
protocol (i.e. serial through USB). The USB cable also serves as a
power supply.



We will describe the Arduino Duemilanove board we have used, in the
sections that follow, but most information will apply to
the other Arduino boards as well.

\section{Pins}
The Arduino board can connect to several external components through
diverse input and output pins. The pins are split in three physical sections on
the board \textit{power}, \textit{analog in} and
\textit{digital}. Before any IO can happen on a pin, it's mode must be
set. The mode of a pin defines if it is used to read input or
write output. The mode is set by the function \texttt{void pinMode(int
  pinnumber, int mode)} where \textit{pinnumber} is a number between
0-5 for analog and 0-13 for digital and \textit{mode} is either of the constants
\texttt{OUTPUT} or \texttt{INPUT}.

\subsection{Power pins}
% http://arduino.cc/en/Reference/Board?from=Guide.Board
\begin{itemize}
\item Reset: Resets the board when connected to ground.
\item 3V3: Constant 3,3v output
\item 5v: Constant 5v output
\item Gnd: Two ground pins
\item Vin: The voltage supplied by the external power supply.
\end{itemize}

\subsection{Digital pins}

There are 14 digital input and output pins. Six of them can also be
used to generate analog output by PWM (Pulse Width Modulation). It's
possible to read a boolean value \texttt{HIGH} and \texttt{LOW} by the
following function \texttt{bool digitalRead(int pinnumber)} where
pinnumber is a number between 0 and 13. It's possible to write a
boolean value by the following function \texttt{void digitalWrite(int
  pinnumber, int value)} where pinnumber is a number between 0 and 13
and value is either \texttt{HIGH} or \texttt{LOW}.

\subsection{Analog input}
There are 6 analog input pins. It's possible to read a voltage level
from each of them using the function \texttt{int analogRead(int
  pinnumber)} where \textit{pinnumber} is a number between 0 and 5
indicating which pin to read from. The result is given as an integer
in the range from 0 to 1023. It's possible to write a voltage level
(PWM wave, explained below) by the following function \texttt{void
  analogWrite(int pinnumber, int value)} where \textit{pinnumber} is
one of (3,5,6,9,10,11) which is located among the 14 digital pins and
\textit{value} is an integer in the range from 0 to 255. The reason
why the 6 analog output pins is located among the digital IO pins is
that the platform uses PWM to generate the desired voltage level.

\subsubsection{PWM}
\label{pwm}
A description of PWM from the Arduino website follows:
\footnote{\url{http://www.arduino.cc/en/Tutorial/PWM} downloaded the
  28. of April at 17:14}

\begin{quotation}
  Pulse Width Modulation, or PWM, is a technique for getting analog
  results with digital means. Digital control is used to create a
  square wave, a signal switched between on and off. This on-off
  pattern can simulate voltages in between full on (5 Volts) and off
  (0 Volts) by changing the portion of the time the signal spends on
  versus the time that the signal spends off. The duration of "on
  time" is called the pulse width. To get varying analog values, you
  change, or modulate, that pulse width. If you repeat this on-off
  pattern fast enough with an LED for example, the result is as if the
  signal is a steady voltage between 0 and 5v controlling the
  brightness of the LED.

  In the graphic below, the green lines represent a regular time
  period. This duration or period is the inverse of the PWM
  frequency. In other words, with Arduino's PWM frequency at about
  500Hz, the green lines would measure 2 milliseconds each. A call to
  \texttt{analogWrite()} is on a scale of 0 - 255, such that
  \texttt{analogWrite(255)} requests a 100\% duty cycle (always on),
  and \texttt{analogWrite(127)} is a 50\% duty cycle (on half the
  time) for example.

  \begin{nonfloatingfigure}
    \centering
    \includegraphics[scale=0.6]{images/pwm}

    \caption{How 0\%, 25\%, 50\%, 75\% and 100\% PWM is measured by a
      oscilloscop. Where Each vertical green line indicates the duty
      cycle}
    \label{fig:pwm}
  \end{nonfloatingfigure}
  
  \fixme{Better figure text and figure should be non-floating. Jesper
    has a solution to this in his old Graphics report}

  Once you get this example running, grab your Arduino and shake it
  back and forth. What you are doing here is essentially mapping time
  across the space. To our eyes, the movement blurs each LED blink
  into a line. As the LED fades in and out, those little lines will
  grow and shrink in length. Now you are seeing the pulse width.
\end{quotation}



\section{Timer Interrupts}

\fixme{fix text to support new heading: timer interrupts}

The ATmega168/ATmega328 processors has three different hardware
timers. One of them (timer 0) is used by Arduino software to provide a
\texttt{millis()} function that gives us the amount of milliseconds
since the timer started and a \texttt{delay} function that actively
holds the processor occupied for a given time period. Timer 0 and 2
uses 8 bit registers and timer 1 uses a 16 bit register. This
effectively means that timer 0 and 2 can't count to more than 255
whereas timer 1 can count to 65535. The registers is incremented at
the speed of the processor, in this case 16MHz, divided by a prescale
factor which can be either of 1 (no scaleing), 8, 64, 256, 1024 for
timer 0 and 1 and either of 1, 8, 32, 64, 128, 256, 1024 for timer
2. The reason why timer 0 and 1 has 2 less prescale factors is that
they can be wired up with an external clock source and setup to
trigger on a falling or rising edge. With a prescale of 256 the
counter is incremented at a rate of $\frac{16000000\mathrm{Hz}}{256} =
62500\mathrm{Hz}$, which makes the counter overflow at a rate of
$\frac{16000000\mathrm{Hz}}{255*256} = \frac{62500\mathrm{Hz}}{255} =
245.1\mathrm{Hz}$ (pr second). This applies to all three timers where the only
2 variables are the prescale and the size of the counter register.

The three timers modes of operation is \texttt{Normal},
\texttt{CTC}(Clear Timer on Compare match), \texttt{Fast PWM},
\texttt{Phase Correct PWM} where \texttt{Normal} and \texttt{CTC} are
the ones of interrest:

\begin{description}
\item[\texttt{Normal}] mode counts from a optionally specified counter
  value (initially default set to 0) and increments until it reaches
  the maximum value 255 where it overruns, restarts from 0, the
  interrupt is triggered and incrementation of the counter
  restarts.

\item[\texttt{CTC}] mode has a predefined top value and optionally
  specified counter value (initially default set to 0). When the
  counter reaches the defined top value it is cleared to 0, the
  interrupt is triggered and incrementation of the counter
  restarts. This gives better resolution of the counter and thus more
  flexibility than the \texttt{Normal} mode.
\end{description}

The modes of operation is described in detail in the processors
datasheet, section 12.7 ``Modes of Operation''.

\subsection{PWM generation}

PWM is generated from these three timers. Pin 5 and 6 are connected to
timer 0, 9 and 10 to timer 1 and pin 3 and 11 to timer 2. This means
that the frequency of the PWM signal is controlled by the speed of
these counters which again is determined by the prescale. When an
\texttt{analogWrite(pinnumber, value)} is executed, the value is
compared against a value in a 8-bit counter (one associated to each
timer). When the counter is less than the specified value it outputs
\texttt{HIGH} on \textit{pinnumber} and \texttt{LOW} otherwise. This
generates a square wave with a duty cycle of 50\% since it is
\texttt{HIGH} on counts $0 \ldots 127$ and \texttt{LOW} on counts $128
\ldots 255$. Since Arduino uses timer 0 for the various time related
functions, the prescale on this timer can't be changed unless this
feature are not to be used. Also because of this the duty cycle of pin
5 and 6 is not exactly the same as the other 4 pins.

\fixme{Interference problems with the PWM output pins.}  

\section{External Interrupts}

Essentially all the pins on the Arduino board supports external
interrupts, though only digital pins 2 and 3 is supported directly by
the Arduino code via the function \texttt{void attachInterrupt(int
  interruptpin, void (* userfunc)(void), int mode)} where
\textit{interruptpin} is either 0 or 1, \textit{userfunc} is the user
function to call when the interrupt triggers and \textit{mode} is one
of \texttt{LOW}, \texttt{CHANGE}, \texttt{RISING} or
\texttt{FALLING}. The \textit{mode} property is special for these two
external interrupt pins, as the other pins only support the
\texttt{CHANGE} mode. The full descriptions of the modes is in the
datasheet of the processor section 10.2.1 ``EICRA - External Interrupt
Control Register A''. To set up external interrupts on the other pins
the user \textit{ckiick} has added an usable header file to the Arduino
playground\footnote{\url{http://www.arduino.cc/playground/Main/PcInt}
  taken 28th of April 2009 at 16:45} also containing an
example of how it works. This header file defines a function
\texttt{void PCattachInterrupt(int interruptpin, void (*
  userfunc)(void), int mode)} where the only difference is that the
\textit{mode} property only supports \texttt{CHANGE}.



\section{Arduino BT}

The Arduino BT board is different from all the other Arduino boards since it
comes with a Bluegiga WT11 Bluetooth chip (from now refered to as WT11 chip)
instead of the USB mount. This means that the board can be programmed and
communicated with through a wireless connection. The communication protocol is
still RS232 so besides the wireless communication nothing is different about
this.

Other main differences as listed at the Arduino
homepage\footnote{\url{http://arduino.cc/en/Main/ArduinoBoardBluetooth} taken
  16th of May at 23:57}:

\begin{itemize}
\item The use of a DC-DC convertor, allowing the board to be powered with a
  minimum of 1.2 V, but with a maximum of 5.5 V. \textbf{Higher voltages or
    reversed polarity in the power supply will kill the board.}

\item A surface-mounted ATmega168 (as with the Arduino Mini). This doubles the
  amount of space available for your sketches and adds three more PWM pins and
  two more analog inputs.

\item Pin 7 is connected to the reset pin of the bluetooth module. 

\item Only use serial communication at 115200 baud; this is the speed that the
  module has been configured to use.
\end{itemize}

As stated digital pin 7 is reserved and connected to the WT11 chip's reset
pin. This means that if a program does a \texttt{digitalWrite(7, HIGH)} and
shortly after does a \texttt{digitalWrite(7, LOW)} the WT11 chip will be
reset. This will however not restore the factory settings of the WT11 chip as
all changes to settings are persistent.

In the below sections it is assumed that the user is using a Unix-like operating
system with Bluetooth associated packages installed, unless otherwise noted.

\subsection{Powering through a USB  cable}

As the board doesn't have the USB mount it is not able to draw power from the
host as most of the other Arduino boards has. This means that the board must be
powered by an external power supply (E.g. batteries). Powering the board when
next to a computer can however still be done through a modified USB cable. As a
standard USB cable consists of 4 wires

\begin{table}[h!]
  \centering
  \begin{tabular}{|c|c|c|}
    \hline
    Contact number & Signal name & Wire colour \\ \hline
    1 & VCC & Red \\ \hline
    2 & D- & White \\ \hline
    3 & D+ & Green \\ \hline
    3 & GND & Black \\ \hline
  \end{tabular}
  \caption{USB Connector Termination Data. Described in the USB 2.0
    specification\cite{usb20} Table 6-1 ``USB Connector Termination Assignment''}
  \label{tab:ArduinoBT:Connector_Termination_Data}
\end{table}

According to the USB 2.0 specification\cite{usb20} Table 7-7 ``DC Electrical
Characteristics'' the VCC wire supplies a minimum of 4.75v and a maximum of
5.25v which is no problem as the Arduino BT board can handle up to 5.5v and as
low as 1.2v. There is however always a slight possibility of faulty equipment
which could damage the board.

The wire colours for a standard USB 2.0 cable are defined in the
specification\cite{usb20} Figure 6-2 ``USB Standard Detachable Cable Assembly''
but it is not all manufactures that comply with this.

To construct the USB power cable all that needs done is to cut off the connector
opposite of the Standard-A connector, which is the one that fits in the
computer. Next strip off the a few cm of the PVC jacket and the copper/aluminium
shield on the cable so the four wires are free. Then cut away the 2 data wires
(green and white) and strip off 0.5cm of the VCC and GND wires insulations (red
and black). Now the two stripped wires can be connected to the Arduino BT board
through the power socket (X1). Remember not to reverse the polarity when
connecting the two wires, ore else the board cold be damaged.

\subsection{Binding with the device}

Before the board can be programmed or communicated with, it must be binded with
a host. To bind with a Bluetooth device, its MAC address is needed. A list of
names and MAC addresses of all Bluetooth devices in the area can be found with
the following command:

\begin{verbatim}
hcitool scan
\end{verbatim}

A factory Arduino BT board is always named \textit{ArduinoBT} and has the PIN
12345. There are at least 2 ways of handling Bluetooth PIN authentication. The
simplest ways is to put the PIN and nothing else in the file
\textit{/etc/bluetooth/pin} before binding with the device this however can be
complicated when binding with multiple devices with different PIN as the file
can only contain a single PIN at a time. The other way is to use
\texttt{bluetooth-applet} (Gnome) or \texttt{kbluetooth4} (KDE), which both
places a icon in the tray and queries the user for a PIN when required by the
Linux Bluetooth stack.

Whichever way is used, the host can now bind with the Arduino BT board with the
following command

\begin{verbatim}
rfcomm bind rfcommX xx:xx:xx:xx:xx:xx 1
\end{verbatim}

where \texttt{rfcommX} is the desired host device that is to be used ex
\texttt{rfcomm0}, \texttt{xx:xx:xx:xx:xx:xx} is the boards MAC Address and
\texttt{1} is the channel to be used. A factory Arduino BT board has only
enabled \texttt{SSP} (Serial Port Profile) and thus this is located on channel
1. It is possible to query which Bluetooth profiles the Arduino BT board exposes
by the following command

\begin{verbatim}
sdptool browse xx:xx:xx:xx:xx:xx
\end{verbatim}

To find the channel, just locate \texttt{SPP} in the returned list and see what
channel the \texttt{rfcomm} protocol is associated with.

\subsection{Important program setup}

When creating a program for the Arduino BT it is important to remember a few
things in the \texttt{setup()} function. This is to ensure that the WT11 chip is
always configured when the program starts. The WT11 chip remembers its settings
even if it loses power. This means that if the settings are change at some point
of the program execution then at least the basic settings will be set to a known
default when the program is restarted. It is however still possible to change
the settings of the WT11 chip so it won't accept connections from any
hosts. This is addressed in the below sections.

\begin{table}
  \centering
\begin{verbatim}
  pinMode(7, OUTPUT);
  Serial.begin(115200);
  digitalWrite(7, HIGH);
  delay(10);
  digitalWrite(7, LOW);
  delay(2000);

  Serial.println("SET BT PAGEMODE 3 2000 1");
  Serial.println("SET BT NAME ARDUINOBT");
  Serial.println("SET BT ROLE 0 f 7d00");
  Serial.println("SET CONTROL ECHO 0");
  Serial.println("SET BT AUTH * 12345");
  Serial.println("SET CONTROL ESCAPE - 00 1");
  Serial.println("SET CONTROL BAUD 115200,8n1");
\end{verbatim}
  \caption{asd}
  \label{tab:ArduinoBT:Initial_Setup_code}
\end{table}


The WT11 chip is connected to the Atmega chip by its RX and TX lines, which
means that communication is done through Arduino's serial communication
capabilities. The WT11 chip communicates at a baud rate of 115200 thus it is
important to use this speed in the \texttt{Serial.begin} function. Even though
the WT11 chip's iWRAP firmware can be changed to use another baud rate, this is
not recommended and will most likely not work. The name that should be visible
when searching to Bluetooth devices is configured by the \textit{SET BT NAME}
command, and the PIN is configured by\texttt{SET BT AUTH *} command. Other iWRAP
commands and their definitions can be seen in the ``iWRAP User Guide''.

\subsection{Communication without Bluetooth}

If the WT11 chip is configured in a way such that it refuses connections or in
some other way that the Atmega chip cannot be programmed, you need to reset to
factory settings (by doing a firmware update) or by changing the individual
settings back to something that works. 

Before settings on the WT11 chip can be changed, they must be directly sent to
it. This can be done by using a 3.3v USB to RS-232 serial converter\footnote{E.g. a
  breakout board with FTDI's FT232RL chip, which is widely available and can be
  used to update the firmware using the DFU protocol as well.
  \url{http://www.sparkfun.com/commerce/product_info.php?products_id=718}} and
connect it to the WT11 chips \texttt{RX} and \texttt{TX} pins which can be
located at the two solder points \texttt{JP1} directly underneth the WT11 chip
on the bottom side of the Arduino board. As \texttt{RX} is the receive line and
\texttt{TX} is the transmit, it is important to cross these two\footnote{Serial
  converter RX goes to WT11 TX and serial converter TX goes to WT11 RX} when
connecting the serial converter and the WT11 chip. No damage will happen if the
lines aren't crossed, but no communication will be able to take place.

There can be some timing issues if using an external power source while using
the serial convert, so it is highly recommended to use the serial converters
3.3v power supply feature.

The most common issues and solutions is

\begin{itemize}
\item If control echo has been enabled it will not be possible to program the
  Atmega chip as the bootloader will receive messages from the WT11 chip at
  bootup and thus fail when waiting for control characters. The solution to this
  is to disable control echo by sending the command \texttt{SET CONTROL ECHO 0}.

\item If the SPP (Serial Port Profile) has been disabled, no host can make a
  serial (rfcomm) connection and thus not make any serial communication (program
  the Atmega chip). The solution to this is to enable the SSP again by sending
  the following command \texttt{SET PROFILE SPP on} and then reset the WT11 chip
  by putting high on pin 7 for a short while or sending the command
  \texttt{RESET}.

\item If bluetooth connection is restored, the serial converter is still
  connected and any attempt to program the Atmega chip fail. Solution to this is
  that the serial converter must not be connected to the Arduino board while
  trying to program the Atmega chip. 

  In fact the serial converter interferes with the signals whether it is
  connected to the WT11 chip or Atmega Chip (digital pins 0 and 1). This results
  in communication only goes between the serial converter and the chip it is
  connected to. So whenever communication between the Atmega chip and the WT11
  chip is desired, the serial converter must be disconnected.
\end{itemize}

\subsection{iWRAP interface}

By default the WT11 chip uses the iWRAP firmware which enables the user to
access Bluetooth functionality with simple ASCII commands sent by a serial
interface. The Arduino BT board is shipped with the iWRAP firmware version 2.2.0
as default. If the Arduino BT board is used with a host that takes care of the
binding then there is properly no need for changing any of the WT11 chips
settings. But if the Arduino BT board is the one who needs to do the binding
with another Bluetooth device then it is necessary to change the settings and
therefor also shift into command mode. A thorough description of the different
iWRAP settings and commands can be seen in the iWRAP 2.2.0 User
Guide\cite{iWRAP220UG}.


\subsubsection{iWRAP modes}

iWRAP can be in three different modes: command,data and mux mode (multiplexing
mode).

Command and data mode are the default behaviour. Before sending any commands to
the iWRAP interface it must be in command mode. The iWRAP interface is always in
command mode when there is no active connections. When a connection is made
iWRAP automatically switches to data mode on this connection.  The mode can be
switched back to command mode by waiting at least one second, sending the
sequence \texttt{esc esc esc} and wait at least one second (\texttt{esc} is the
defined escape character\footnote{The escape character is defined by the iWRAP
  command \texttt{SET CONTROL ESCAPE}}). When in command mode the \texttt{LIST}
command will list all active connections and \texttt{SELECT} \textit{link\_id}
command will switch to data mode on the specified connection. Command/data mode
has the advantage of being easy and fairly intuitive when operating one a small
amount of active connections (preferably only one connection) but when multiple
connections is used the mode switching becomes quite a bottleneck as iWRAP needs
to be in data mode on the desired connection to receiving data and if it is in
command mode or data mode on another connection the data is stored in a buffer
and thus could potentially be lost if the buffer overflows before the connection
is selected.

This can however be solved by using multiplexing mode. In multiplexing mode data
and command mode is melted into one mode and it uses a special protocol which
doesn't accept normal iWRAP ASCII commands. Instead the multiplexing protocol is
a ASCII list of space separated hex values that contains some control segments
which defines whether the data part is a control (iWRAP command) sequence or
which connection the data sequence should be sent to or is received
from. \Fref{tab:multiplexing_protocol} illustrates the multiplexing frame
format.

\begin{table}[h!]
  \centering
  \textsf{
    \begin{tabular}{|l|l|l|l|}
      \hline
      \textbf{Length:} & \textbf{Name:} & \textbf{Description:} & \textbf{Value:} \\ \hline
      8 bits & SOF & Start of Frame & \texttt{0xBF} \\ \hline
      8 bits & LINK & Link ID & \texttt{0x00}--\texttt{0x08} or \texttt{0xFF} for
      control commands \\ \hline
      6 bits & FLAGS & Frame Flags & \texttt{0x00} \\ \hline
      10 bits & LENGTH & Size of data field in bytes & - \\ \hline
      0-800 bits & DATA & Data & - \\ \hline 
      8 bits & nLINK & LINK \texttt{xor} \texttt{0xFF} & - \\ \hline 
    \end{tabular}
  }
  \caption{Multiplexing frame format as described in Table 4 of the iWRAP 2.2.0 User
    Guide}
  \label{tab:multiplexing_protocol}

\end{table}

When multiplexing mode is enabled\footnote{To enable multiplexing mode send the
  iWRAP command \texttt{SET CONTROL MUX 1}}, it can be disable by the following
sequence \texttt{BF FF 00 11 53 45 54 20 43 4f 4e 54 52 4f 4c 20 4d 55 58 20 30
  00} which should be send as its ASCII representation without spaces. A python
script that demonstrates this can be seen in \fref{sec:python-demux-script}.

The sequence breaks down to the following

\begin{center}
  \begin{tabular}{|l|p{300pt}|}
    \hline 
    \textbf{Name:} & \textbf{Description:} \\ \hline
    \textsf{SOF} & Is always \texttt{0xBF} \\ \hline
    \textsf{LINK} & Is \texttt{0xFF} as it is a control command \\ \hline
    \textsf{FLAGS} & Is always \texttt{0x00} \\ \hline
    \textsf{LENGTH} & Is \texttt{11} (length of data is 17 characters) \\ \hline
    \textsf{DATA} & Is \texttt{53 45 54 20 43 4F 4E 54 52 4F 4C 20 4D 55 58 20
      30} which is the hex representation of \texttt{SET CONTROL MUX 0} \\ \hline
    \textsf{nLINK} & is \texttt{0x00} as \texttt{0xFF xor 0xFF = 0x00} \\ \hline
  \end{tabular}
\end{center}
 
iWRAP commands should not end with ``$\backslash$r'' or
``$\backslash$r$\backslash$n'' when used in a multiplexing frame.

The iWRAP 2.2.0 User Guide states that there can be used four simultaneous
connections in multiplexing mode, though iWRAP 3.0.0 User Guide\cite{iWRAP300UG}
states in section 6.20.3 on page 120 that 

\begin{quote}
  In MUX mode the processor of the module is highly utilised and on the edge of
  its performance. This may be seen as a instability of Bluetooth connections,
  especially if 3 or more connections are used or data rate is high.
\end{quote}

\noindent
and suggests to use \texttt{SNIFF} mode and optimise the bluetooth packet size
by using the MTU option in the \texttt{CALL} command to leave more time for the
processor to parse the multiplexing protocol. 

Section 3 of the iWRAP 2.2.0/3.0.0 User Guide covers the three iWRAP modes in
depth.


\subsubsection{Firmaware update}

Bluegiga Technologies support 2 ways of updating the firmware. A proprietary SPI
protocol that uses a SPI interface or a open DFU (Device Firmware Update)
protocol\footnote{The DFU protocol description can be retrieved by contacting
  the Bluegiga support team.} which uses a DFU interface over a UART or USB connection.

The downside of the SPI interface is that 

\begin{itemize}
\item it requires a special SPI cable which basically is a parallel to SPI cable
  converter.

\item The proprietary BlueSuite software supplied by Bluegiga Technologies used
  to update the firmware is only released for Windows\footnote{It has not been
    confirmed whether or not it works on Linux through Wine}.

\item It is necessary to have direct access to the WT11 chip's SPI interface.
\end{itemize}

Downside of DFU interface is that 

\begin{itemize}
\item it requires special version of the firmware which can be obtained by
  contacting the Bluegiga support team.

\item It is however not all firmware versions that can be update through the DFU
  interface\footnote{``... For example iWRAP 2.1.0 can not be updated to iWRAP
    2.2.0, since the DFU boot loader code has changed''
    (\url{http://techforum.bluegiga.com/faq_item?id=10377296} 17th of may at
    19:36)}.

\item It is necessary to have access to the WT11 UART or USB
  interface. This can however be done by uploading a program to the host
  processor through Bluetooth and make it do the firmware upgrade.
\end{itemize}

Bluegiga Technologies recommends to buy or build\cite{oik_chematic} a OIK
(OnBoard Installation Kit), but the Arduino community has posted an
alternative schematic\cite{oik_chematic_arduino}.

\fixme{this section needs restructuring.}
\fixme{this section is outdated. Firmware update has been done another way.}

\chapter{Problems in Flask}
We've detected a few Flask problems, that we think should be fixed.

\begin{itemize}
\item Pattern-matching isn't handled correctly. The following program
  is compiled as if the two first cases where overlapping (i.e. the
  second case would be ignored)
\begin{verbatim}
f (1, (1, x)) = 2
f (1, (2, x)) = 3
f (2, _) = 3
\end{verbatim}

\item Lack of type-classes in Red
\item In Red, negation with \texttt{negate} and \texttt{(-)} only works for
  integers. (Probably related to the lack of type-classes).
\end{itemize}

\chapter{Guide to electronics}

\fixme{Maybe a little refresher on electronics (e.g. how each
  component are drawn in a diagram, if we are going to use diagrams in
  the article). }

\chapter{Code snippets}

\section{Python demux script}
\label{sec:python-demux-script}

This is a python script that sends the iWRAP command \texttt{SET CONTROL MUX 0}
to disable multiplexing mode. This assumes that the breakout board is connected
to the WT11 chips serial communication pins and connected to the computer at
\textit{/dev/ttyUSB0}.

\begin{verbatim}
#!/usr/bin/python

# sets str to '\xbf\xff\x00\x11SET CONTROL MUX 0\x00'
str = 'BFFF001153455420434f4e54524f4c204d5558203000'.decode("hex")

f = open('/dev/ttyUSB0', 'w')
f.write(str)
f.close()
\end{verbatim}

\end{document}
