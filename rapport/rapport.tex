\documentclass[a4paper,oneside, draft]{memoir}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

% bedre orddeling Gør at der som minimum skal blive to tegn på linien ved
% orddeling og minimum flyttes to tegn ned på næste linie. Desværre er værdien
% anvendt af babel »12«, hvilket kan give orddelingen »h-vor«.
\renewcommand{\englishhyphenmins}{22} 

\usepackage{colortbl}  % Bruges til at farve celler, rækker mv. i tabeller
\usepackage{pdflscape} % Gør landscape-environmentet tilgængeligt
\usepackage{fixme}     % Indsæt "fixme" noter i drafts.
\usepackage{hyperref}  % Indsæter links (interne og eksterne) i PDF


\renewcommand{\ttdefault}{pcr} % Bedre typewriter font
%\usepackage[sc]{mathpazo}     % Palatino font
\renewcommand{\rmdefault}{ugm} % Garamond
\usepackage[garamond]{mathdesign}

%\overfullrule=5pt
%\setsecnumdepth{part}
\setcounter{secnumdepth}{-1} % Sæt overskriftsnummereringsdybde. Disable = -1.

\newcommand{\EDSL}{EDSL (Embedded Domain Specific Language) \renewcommand{\EDSL}{ EDSL }}

\title{Controlling embedded devices with funktional reactive programming}

\author{Martin Dybdal (dybber@dybber.dk), \\
Jesper Reenberg (jesper.reenberg@gmail.com) \\ og
Troels Henriksen (athas@sigkill.dk)}

\date{\today}
\pagestyle{plain}



\begin{document}
\maketitle

\begin{abstract}
  Robots are conventionally programmed in low-level imperative
  languages with no concepts like events, synchronicity or any of the
  advantages found in functional programming languages (like pattern
  matching). Reactive programming languages embedded in Haskell, like
  Frob \cite{frob99} and Yampa \cite{arrowsrobotsfrp02}, has been
  suggested for robot programming, but they require a complete Haskell
  runtime system, which is to large to fit on more
  resource-constrained devices. We tie these two ends together,
  creating a highly declarative language for robot programming using a
  staged-compilation strategy like the one found in Flask
  \cite{flask08}, that makes it possible to run programs on devices
  with few resources. In the creation we've used the Flask-codebase as
  a starting point and huge parts of the code is left unchanged.
\end{abstract}


\section{Disposition}
\begin{itemize}
\item Abstract

\item Preface
  \begin{itemize}
  \item Brief intro to robot programming
    \begin{itemize}
     \item Sensors and Actuators
    \end{itemize}
  \item Brief Arduino introduction
  \item Brief Flask introduction
    \begin{itemize}
     \item The staged compilation strategy
    \end{itemize}
  \end{itemize}

\item Previous Work
  \begin{itemize}
  \item Frob
  \item Esterel
    (http://www.softwaresafety.net/Esterel.org/esterel.html)
  \item Lustre \cite{lustre91}
  \item Flask
  \end{itemize}

\item "`Our system"'
  \begin{itemize}
  \item Staged compilation
  \item Dataflows
  \item Node representation
  \item Devices
  \item Interrupts
  \item Events
  \end{itemize}

\item Example programs

\item Conclusions

\item Bibliography

\item Appendixes
  \begin{itemize}
  \item A Flask tour
  \item Small guide to Arduino and electronics
  \end{itemize}
\end{itemize}  

\bibliographystyle{plain}
\bibliography{rapport}

\appendix

\chapter{Small guide to Arduino and electronics}
Arduino is an Open Source project ... hardware ... software
... prototyping.

\fixme{<<Image of our Duemilanove>>}

There are different kinds of Arduino boards. All are based on
different ATmega* processors from Atmel. The older boards used serial
communication while the newer are connected to a computer through a
USB cable, but still using the same serial communication protocol
(i.e. serial through USB). The USB cable also provides power for the
board.  

We will describe the Arduino Duemilanove board we have used in the
sections that follow, but most (if not all) information will apply to
the other Arduino boards as well.

\section{Pins}
The Arduino board can connect to several external components through
diverse input and output pins. The pins are split in three sections on
the board \textit{power}, \textit{analog in} and \textit{digital}.

\subsection{Power pins}
\begin{itemize}
\item Gnd: Ground
\item 5v: constant 5v output
\item Reset: resets the board when connected to ground. \fixme{tror jeg i
    hvert fald..}
\item 3V3: ???
\item Vin: ???
\item Sixth pin: ???
\end{itemize}

\subsection{Analog input}
There are 6 analog input pins. It's possible to read a voltage level
from each of them using the function
\texttt{int analogRead(int pinnumber)} where \textit{pinnumber} is a
number between 0 and 5 indicating which pin to read from. The result is given
as an integer in the range from 0 to 1023.

\subsection{Digital pins}
There are 14 digital input and output pins.
\fixme{description of how to use them and special features of the
  different pins}


\section{Timers}
The ATmega168/ATmega328 processors has three different hardware
timers. One of them is used by arduino software to provide a
\texttt{millis()} function that gives us the amount of milliseconds
since the timer started and a \texttt{delay} function that actively
holds the processor occupied for a given time period.

\fixme{...which are 8 bit and 16 bit timers. Interference problems with the
PWM output pins.}

\section{Electronics}
\fixme{Maybe a little refresher on electronics (e.g. how each
  component are drawn in a diagram, if we are going to use diagrams in
  the article). }

\chapter{Implementation}

The essence of Fladuino can be condensed to a single, conceptually
simple problem: translate a high-level functional reactive program to
a form suitable for execution on the Arduino platform.  We have chosen
to stop a step short, and merely generate C code meant for further
compilation through an Arduino-specific compiler.  We have no need of
the additional power we would gain through generating our own machine
code, and the additional amount of work required would be very large.
Flask chooses the same approach, in that it produces NesC--code for
running on sensor motes, likely for the same reasons.

Our target platform, Arduino, imposes constraints on the resulting
device-level code.  In particular, the low amount of available main
memory, and the comparatively large amount of available flash memory
for program code, suggests that we optimise for low memory usage over
low code size.  Indeed, as we shall see, we have opted to directly
express much of the control flow in the code itself, where a typical
program, with plenty of available memory, might instead choose a more
data-driven approach.

\section{Basic dataflow translation}

At their heart, both Flask and Fladuino--programs consist of an
acyclic dataflow graph.  A core part of the system involves the
translation of this high-level description of the passage of data into
the procedural target environment.  Fladuino adopts Flask's
implementation almost verbatim, the details of which will be explained
within this chapter.

As in Flask, the graph is divided into \textit{atomic subgraphs},
sections that can be executed without blocking

\subsection{Translation of a simple dataflow graph}

A set of nodes connected by a set of directed graph edges make up the
entirety of the dataflow graph.  We shall adopt the terminology of
Flask, and refer to nodes as \textit{dataflow operators} and the
directed edges as \textit{wires} in the following.  Some dataflow
operators have no predecessor and exist solely as entry points for
data (they can be triggered by outside events, such as device or timer
interrupts), while others have no successors and function as data
sinks.  It is required that the graph is acyclic, something that is
enforced by every operator being uniquely identified by (among other
things) its predecessor(s).

For every operator $o$ in the dataflow graph, two unary functions will
be generated: $o\_in()$ and $o\_out()$.  Whenever a value $v$ arrives
at $o$, this will be implemented by a call $o\_in(v)$.  Depending on
the specific semantics of $o$, a value $v'\equiv f(v)$ (where $f()$
represents the computation done by $o$, the result may not even depend
on $v$ at all) may be propagated to the successors of $o$.  In this
case, $o\_in(v)$ will call $o\_out(v')$, the implementation of which
will feature the calls $\forall s \in S(o). s\_in(v')$, where $S(o)$
is the set of all successors of $o$.

$o\_in()$ is generated directly by the implementation of the specific
dataflow operator, but $o\_out()$ is automatically created by Fladuino
during code generation.  The utility of this division is that the
implementation of a dataflow operator does not feature tedious
duplication of the value propagation machinery, yet as it is not
required that $o\_out()$ is called at all, each dataflow operator can
still make it own choice whether to propagate a value or not.

\end{document}
