\documentclass[a4paper, oneside, final]{memoir}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

% bedre orddeling Gør at der som minimum skal blive to tegn på linien ved
% orddeling og minimum flyttes to tegn ned på næste linie. Desværre er værdien
% anvendt af babel »12«, hvilket kan give orddelingen »h-vor«.
\renewcommand{\englishhyphenmins}{22} 

% Fix of fancyref to work with memoir. Makes references look
% nice. Redefines memoir \fref and \Fref to \refer and \Refer.
% \usepackage{refer}             %
% As we dont really have any use for \fref and \Fref we just undefine what
% memoir defined them as, so fancyref can define what it wants.
\let\fref\undefined
\let\Fref\undefined
\usepackage{fancyref} % Better reference. 

\usepackage{colortbl}  % Bruges til at farve celler, rækker mv. i tabeller
\usepackage{pdflscape} % Gør landscape-environmentet tilgængeligt
\usepackage[draft]{fixme}     % Indsæt "fixme" noter i drafts.
\usepackage{hyperref}  % Indsæter links (interne og eksterne) i PDF

\usepackage[format=hang]{caption,subfig}
\usepackage{graphicx}

\renewcommand{\ttdefault}{pcr} % Bedre typewriter font
%\usepackage[sc]{mathpazo}     % Palatino font
\renewcommand{\rmdefault}{ugm} % Garamond
%\usepackage[garamond]{mathdesign}

%\overfullrule=5pt
%\setsecnumdepth{part}
\setcounter{secnumdepth}{1} % Sæt overskriftsnummereringsdybde. Disable = -1.
\chapterstyle{hangnum} % changes style of chapters, to look nice.

\makeatletter
\newenvironment{nonfloatingfigure}{
  \vskip\intextsep
  \def\@captype{figure}
  }{
  \vskip\intextsep
}

\newenvironment{nonfloatingtable}{
  \vskip\intextsep
  \def\@captype{table}
  }{
  \vskip\intextsep
}

\makeatother


\newcommand{\EDSL}{EDSL (Embedded Domain Specific Language) \renewcommand{\EDSL}{ EDSL }}

\title{Controlling embedded devices with functional reactive programming}

\author{Martin Dybdal (dybber@dybber.dk), \\
Jesper Reenberg (jesper.reenberg@gmail.com) \\ og
Troels Henriksen (athas@sigkill.dk)}

\date{\today}
\pagestyle{plain}



\begin{document}

\maketitle

\begin{abstract}
  Robots are conventionally programmed in low-level imperative
  languages with no concepts like events, synchronicity or any of the
  advantages found in functional programming languages (like pattern
  matching). Reactive programming languages embedded in Haskell, like
  Frob \cite{frob99} and Yampa \cite{arrowsrobotsfrp02}, has been
  suggested for robot programming, but they require a complete Haskell
  runtime system, which is to large to fit on more
  resource-constrained devices. 

  We tie these two ends together, creating a highly declarative
  language for robot programming using a staged compilation-strategy
  like the one found in Flask \cite{flask08}, that makes it possible
  to run reactive control programs on devices with few resources. In
  the creation we've used the Flask-codebase as a starting point and
  huge (isolated) parts of the code is left unchanged. Our
  contribution includes functionality suitable for the robot domain,
  including a framework for specifying interfaces to peripherals (like
  sensors, motors or displays), primitives for event-handling and
  (\ldots).
\end{abstract}

\clearpage 

\tableofcontents*

\fixme{remove all uses of "`very"'}
\fixme{change bibtex style to one that includes URL's in the generated list,
  such as plain-url or another fancy one.}
\fixme{change $\backslash$ url to use the hyperref package so real links are
  used.}
\fixme{check all quoted text for use of the same quotes!!!!}
\fixme{Check all cites. Should there be a space between the word and cite or
  not.}
\fixme{Check all refs. Should be converted to vref to utilize the varioref package}

\chapter{Disposition}
\begin{itemize}
\item Abstract

\item Preface 

\item Introduction
  \begin{itemize}
  \item Brief intro to robot programming
    \begin{itemize}
     \item Sensors and Actuators
    \end{itemize}
  \item Brief Arduino introduction
  \item Brief Flask introduction
    \begin{itemize}
     \item The staged compilation strategy
    \end{itemize}
  \end{itemize}

\item Related Work
  \begin{itemize}
  \item Frob
  \item Esterel
    (http://www.softwaresafety.net/Esterel.org/esterel.html)
  \item Lustre \cite{lustre91}
  \item Flask
  \end{itemize}

\item "`Our system"'
  \begin{itemize}
  \item Staged compilation
  \item Dataflows
  \item Node representation
  \item Devices
  \item Interrupts
  \item Events
  \end{itemize}

\item Example programs

\item Conclusions

\item Bibliography

\item Appendixes
  \begin{itemize}
  \item A Flask tour
  \item Small guide to Arduino and electronics
  \end{itemize}
\end{itemize}  



\chapter{Preface}
This report is a 15 ECTS Bachelor project at the Computer Science
Department (DIKU), University of Copenhagen. The authors are Martin
Dybdal, Troels Henriksen and Jesper Reenberg. The project is
supervised by Ken Friis Larsen, assistant professor at DIKU.

\fixme{maybe add thanks to Flask-guys}


\chapter{Introduction}

Robots has been used in the industry for decades, replacing humans in
repetitive tasks like sewing, assembling and transportation. In the
last years, robots have been introduced to the consumer market,
e.g. the Roomba vacuum cleaner. This is quite probably be a sign that
robots are getting cheaper an affordable for more tasks. In the future
we will probably see robots deployed in many other uses. But falling
hardware prices is not everything, efficient development and
prototyping of robot control programs is another aspect in making
robots affordable. \fixme{code reusability}

It is the prevailing conception that robots has some sort of
autonomous behavior. A simpler definition, says that a robot is any
programmable electronic system that is equipped with sensors and
actuators. The second definition is more general, in that it applies
to almost any programmable electronic system, and the autonomous
behavior will often be achieved programmatically. 

\fixme{something about how robots are normally programmed, maybe a bit
  specific about arduino}

Our goal is to provide a framework that facilitates robot programming
(specifically for the Arduino-platform), but such a framework also has
to provide features for programming the kind of input-output systems
which doesn't necessarily have any autonomous behavior. So there are
actually two steps: making a library suitable for programming sensors,
actuators and connecting them, and secondly facilitate programming
autonomous robots.

Robots are reactive systems. We've found the best description of what
distinguishes a reactive system in Zhanyong Wan's PhD
thesis ``Functional Reactive Programming for Real-Time reactive
systems'' \cite{Chambers1992}.  As he explains we can
partition computer systems into:
\begin{itemize}
\item Transitional systems, that takes some data as input, does some
  computation on it and delivers some resulting output (an example of this
  is a compiler).
\item Interactive systems, where the state of the program switches
  from computation to getting more input and back (a text editor is an
  example).
\item Reactive systems that continuously has to respond to
  environmental changes. Often reactive systems has to do with our
  physical environment, either simulating it (e.g. a computer game) or
  is required to respond to its changes (e.g. a robot).
\end{itemize}

A reactive programming language is a language with primitives for connecting
processes (a kind of ever-changing input values, often called signals). 

The choice of hardware-platform has an influence on how to design such a
language. We've chosen to make our language and framework target the
Arduino-platform \cite{arduino}.  There are number of reasons for why we think
this platform is a good choice. First of all, our institute DIKU was planning on
buying a couple of these boards for research in Human Centered Computing about
interactive-objects.\fixme{måske en forklaring af hvorfor vi laver noget andet
  end HCC med dem?} And they finally bought some in the first weeks of our
project. \fixme{Det er da fuldstændig ligegyldigt om HCC gruppen havde planer om
  at købe disse} Even better reasons is that they are cheap (approximately 200 DKK for
an Arduino Duemilanove, at the time of writing) and is easily
extensible. E.g. you can buy extensions for ethernet, bluetooth, or even small
touchscreens. Finally, the Arduino comes with a reltively high-level
C-interface, sparing us from most low-level programming and bit trickery.

Because the Arduino processor has a relatively limited computation capacity, we
had to find a way of programming these systems \ldots

\fixme{flask, dataflow, etc.}

\fixme{Introduktion til resten af rapporten. Hvad forklarer de forskellige chapters.}

\section{A note on Arduino}

The term ``Arduino'' is somewhat ambiguous.  It is both a registered
trademark of the Arduino team that can be used by licensed
manufacturers, a line of platforms based on various Atmel AVR
microcontrollers, as well as a general term for any device that is
mostly compatible with the official Arduino microcontroller boards.
This paper will use the latter meaning unless otherwise is explicitly
mentioned.  We will use the term ``an Arduino board'' to refer to the
physical package of microcontroller and I/O ports.

Additionally, we have only had resources to test our work on the
Arduino
Duemilanove\footnote{\url{http://www.arduino.cc/en/Main/ArduinoBoardDuemilanove}},
Arduino BT\footnote{\url{http://www.arduino.cc/en/Guide/ArduinoBT}},
Arduino
Mega\footnote{\url{http://arduino.cc/en/Main/ArduinoBoardMega}},
and Pololu 3pi\footnote{\url{http://www.pololu.com/catalog/product/975}}.

\chapter{Flask}
Flask is a domain specific language embedded in Haskell for
programming sensor networks. Flask is based on the idea of writing
\textit{dataflows} that express the overall flow of data in the
program. The basic task in writing a Flask program is thus to connect
incoming streams of sensor data to outgoing streams of data (e.g. to
other nodes in the network) with some eventual data processing in
between. A program thus takes form of an acyclic graph.

A fundamental thing in Flask is its compilation and
execution-strategy. A Flask program is a description of the before
mentioned dataflow-graph written in Haskell, using specialized
Haskell-operators (dataflow-operators, stream-combinators,
stream-operators or signal-functions) for connecting and manipulating
the streams. Some of the these stream-operators also accepts some
node-level code which should be inserted into the dataflow. This
node-level code is written in one of several object-languages (where Haskell is
the meta-language) for manipulating node-level values. 

When compiling the Haskell program description of the dataflow graph,
you end up with an executable that generates and outputs code in a
sensor network language called NesC\footnote{NesC is an extension to
  C, with some additional constructs suitable for low-level sensor
  network programming for TinyOS.}.

The generated NesC code can then be translated by an ordinary
NesC compiler to machine code running on the nodes in the
sensor network.  Thus, when you write a Flask-program, you use
ordinary Haskell constructs to manipulate which NesC-code should
ultimately be generated.

\begin{nonfloatingfigure}
  \includegraphics[width=0.9\textwidth]{images/flask-simple}
  \centering
\end{nonfloatingfigure}

\section{Streams, node-level values and dataflow-operators}




A program is a description of the flow of data from inputs
(e.g. hardware sensor) to outputs (e.g. another node) in the specific
sensor node. The description takes the form of an acyclic graph
connecting inputs to outputs, with some optional processing in
between. For specifying this \textit{dataflow graph}, Flask provides
some general \textit{signal functions} that can be combined with
\textit{node-level code} (code that is actually getting to run on the
sensor-nodes) written in one of the object-languages.

Example dataflow graph from the Flask paper: 

\begin{figure}
  % ewma example
\end{figure}

Flask provides two object-languages: NesC and Red. Having NesC as an
object-language, allows the user to write all programs that's expressible in
NesC. Red is an amputated Haskell language, without recursion, recursive
datatypes, most of the standard library and curried functions. It allows you to
write concise functions for simple tasks instead of having to deal with
NesC. The reason for disallowing these things are the same as for not compiling
Haskell directly to the sensor nodes in the first place: the Haskell runtime is
too huge to fit in the limited memory of a sensor node.

Both languages are integrated into Flask using the quasiquotation library
\cite{quasiquote07}, written by the Flask author Geoffrey Mainland. This allows
you to write the object languages in their original syntax inside the
Flask/Haskell environment. And it allows you to intersperse generation time
variables (which results in compile time constants) into object language code.



\begin{verbatim}
More on:
  Typechecking
  Dataflow
\end{verbatim}

\section{Streams and node--level values}
\texttt{smap} (\textit{some Red or NesC code})

\subsection{\texttt{Reify}/\texttt{LiftN}}

\section{Red --- a restricted node--level language}
Red is an object-language from Flask that is meant to be used for
writing node--level mapping functions, like predicates or conversion
functions. It takes it syntax from Haskell, but is restricted to a
very small subset of what is normally expressible in Haskell.  As
mentioned before\fixme{I hope this is mentioned in the introduction},
the Haskell runtimes are too large to fit on the Arduino an therefore
we can't allow uses of features that e.g.  requires a garbage
collector. Flask disallows the following Haskell '98-features from Red:
\begin{itemize}
\item Recursive function
\item Recursive datatypes
\item Higher-order functions
\item Type classes
\item Laziness
\item Modules
\end{itemize}

And the only a very small subset of the Standard Prelude is included
in Flask. Type classes should be possible to implement though, since
it's a compile-time thing.


\chapter{Design of the Fladuino system}

Fladuino is a modification of Flask that can be used to program
Arduino devices in a functional reactive manner.  Our final program is
governed by the following requirements.

\begin{itemize}
\item Fladuino must be able to generate a C--program suitable for
  running on an Arduino from a description of a dataflow graph.  This
  graph must be expressed in the form of a Haskell program.
\item The C--program generated must be \textit{valid}, except for any
  custom C--code included by the user.
\item We shall not describe the implementation of any specific
  reactive program with Fladuino, nor will we attempt to support the
  writing of any such specific program.  We shall endeavour to support
  functionality outside our core requirements only insofar as it is
  useful for evaluating Fladuino as a whole.
\item The design of Fladuino must mirror similar core design choices
  in Flask.
\item To the extent that it is possible, we must statically analyse
  the program for validity (type or logic errors).
\item It must be possible to define interfaces to external devices
  connected to an Arduino board, without having to modify Fladuino
  itself.  Interaction with these devices must take place through the
  same statically typed stream operator (and event) interface as any
  built-in part of Fladuino.
\item It must be possible to define simple variations on Arduino
  boards in terms of I/O--pin availability and custom capabilities,
  without having to modify Fladuino itself.  Implementing support for
  platforms that differ significantly from our built-ins (for example,
  using a different microcontroller) will not be possible without
  modifying the Fladuino libraries themselves, however.
\item It is not required that we attempt to handle all error
  conditions.  We accept that hardware constraints pose certain hard
  restrictions (such as memory limits, integer counter overflow and
  CPU time starvation), and declare that writing a program with
  Fladuino that exceeds these constraints will result in information
  loss or undefined behaviour.  We shall, however, endeavour to design
  Fladuino so as to reduce the likelihood of these errors.
\end{itemize}

\section{Terminology and basic \textit{modus operandi}}

As in Flask, Fladuino is implemented as a set of Haskell modules that
provides facilities for expressing the structure and behaviour of a
\textit{dataflow graph}, connecting \textit{dataflow operators}
through value-carrying directed graph edges (\textit{wires}).  The
programmer writes a Haskell program, called the \textit{generator
  program}, or just the \textit{program}.  We shall refer to the
compilation of the program as \textit{compile--time}, and execution of
the program as \textit{generation--time}.  At generation--time, the
output will be a program source file suitable for further compilation
with the Arduino tools, but these are not part of the Fladuino system.
Generation--time may also terminate erroneously if the program
contains static errors: in this case, an error message with a
description of the problem will be printed.  Only errors that are
violations of the Haskell type system can be caught at compile--time,
and while we have attempted to structure the facilities provided by
Fladuino such that invalid programs will contain type errors, this
cannot be done for all error classes.

\fixme{We ought to have a little description of which types of errors is caught
  at which point. Seems a little quick to mention it but not to clarify}

\section{Hardware constraints}

While we do not use ``Arduino'' to refer to any specific hardware
configuration, implementations of our target platform still share some
fundamental characteristics that have influenced many design choices
and tradeoffs in Fladuino.  In particular, the low amount of available
main memory, and the comparatively large amount of available flash
memory for program code, suggests that we optimise for low memory
usage over low code size.  Indeed, as we shall see in
\ref{dataflowtranslation}, we have opted to directly express much of
the control flow in the code itself, where a typical program, with
plenty of available memory, might instead opt a more data-driven
approach.  This choice was also made in Flask itself, and as
\cite{flask08} observes, such static dataflow is not a problem for a
large class of applications.  Additionally, we recover much of the
lost flexibility through programmatic wiring of the dataflow graph at
generation--time.

\section{Structural overview}

Fladuino consists of several interconnected parts combined to form a
domain-specific language embedded in Haskell.\footnote{We do however
  make heavy use of Glasgow Haskell language extensions, such as
  multi--parameter typeclasses and existential types, so Fladuino will
  not run in a standard implementation of Haskell 98.}  As in Flask,
this takes the form of providing facilities to express the structure
of a \textit{dataflow graph}, connecting \textit{dataflow operators}
through directed graph edges (\textit{wires}).  Conceptually, these
parts can be divided into the following:

\begin{itemize}
\item Haskell operators and functions used to describe the dataflow
  graph have been defined.  It is not intended that these are
  exclusively used to construct the program, but rather that they are
  part of a larger Haskell program.  Since a Fladuino program is
  highly static at run-time, the generating program should be written
  to support easy configuration and modification.  In a very real
  sense, the dynamic part of a Fladuino program happens at
  compile--time.
\item A compiler is supplied for the Haskell-like programming language
  Red, which is used to tailor the behaviour of stream operators.
\item A module that encapsulates the hardware facilities offered by
  the target platform and provides the ability to check whether the
  requirements made by the users program can be fulfilled.  Arduino is
  a highly variable hardware platform, no more than a simple
  microcontroller connected to a basic extensible circuit board, and
  no assumptions can be made about which electrical components the
  user might need to control.  Therefore we provide a comprehensive
  facility for expressing device interaction in a high-level fashion,
  and automatically check whether any of these interactions are
  incompatible, or violate basic hardware restrictions.  For example,
  we might check that the program does not try to interact with a
  pushbutton connected to a hardware pin that does not support
  interrupts, or that the program does not express both a
  potentiometer and diode connected to the same pin.\footnote{Of
    course, it must be mentioned that we cannot possibly check that
    the hardware has actually been set up in the way described by the
    program --- we can only check for internal consistency and
    violations of basic hardware restrictions, not whether the
    programs model of the device actually corresponds with reality.}

  Furthermore, since there are several different boards under the
  Arduino name, all with slightly different capabilities, we permit
  selection of the exact Arduino variant targeted by the program.

  Finally, since Arduino is a fundamentally extensible platform, we
  provide facilities for implementing \textit{drivers} for entirely
  new devices, such that use of these is also automatically
  sanity-checked.
\end{itemize}

\section{Dataflow evaluation strategy}

As in Flask, the dataflow graph is divided into \textit{atomic
  subgraphs} consisting of a set of nodes connected by normal wires.
Evaluating such a subgraph consists of supplying a value on the input
wire, retrieving any values that may show up on output wires, then
setting up to evaluate any of the successor atomic subgraphs with
these values (see \ref{dataflowtranslation} for the implementation
details).  The notion of an atomic subgraph serves the purpose of
dividing the dataflow graph into parts that can be evaluated
atomically without blocking.  While this is conceptually and
implementation--wise simple, it leaves open the question of what to do
with the asynchronous events that are the heart of reactive
programming.  Since events are fundamentally connected to the concept
of a hardware interrupt (though we do not reject the ability for sinks
to manually signal events), we cannot at any time predict, or control,
their arrival.

The simplest strategy would be to, upon arrival of an event via an
asynchronous hardware-level interrupt, immediately evaluate all atomic
subgraphs that have nodes listening to the event.  However, this
approach is unacceptable for several reasons:

\begin{itemize}
\item If we are already in the progress of computing an atomic
  subgraph $s_1$ already, we will have to store information about the
  computation while we evaluate all graphs $s_n$ listening to the
  newly arrived event.  The size of this information can be
  significant, especially if we receive yet another event while
  evaluating one of $s_n$.  There is no upper bound on the number of
  events we can be forced to handle within each other, and the storage
  spent on saving the state of each computation can be very
  significant on such memory-constrained devices as the Arduino
  platform.
\item Doing large computations (in space or time) within interrupt
  handlers is generally a bad idea.  Not only are additional
  interrupts disabled while running the handler (and making them
  re--entrant is nontrivial), but the already running code may already
  tie up an arbitrary amount of the memory resources.  As a result,
  interrupt handlers should ideally terminate swiftly and use very few
  resources, which cannot be guaranteed for evaluation of arbitrary
  atomic subgraphs.
\item Most importantly, the subgraph computation already in progress
  may be in a critical section, and we cannot guarantee that the
  subgraphs to be evaluated in response to the event will not overlap
  with this critical section.  Thus, we can end up with interleaved
  access to explicit state (memory contents) as well as implicit state
  (output).  This violates one of the basic tenets of atomic
  subgraphs, namely atomicity of computation.
\end{itemize}

As a result, our basic program evaluation is as follows.  We maintain
an ordered \textit{event queue}, each element containing information
about an atomic subgraph (actually, an entry node to the subgraph)
that should be called, as well as the input value that caused the
input wire to fire.  The generated program consists of a loop that
continuously checks for the presence of an element in the queue, and
if so, removes it and computes the subgraph indicated by it.  Hardware
interrupts are handled by checking all events that may be signalled by
the given interrupt (the details of this check are defined
individually by each type of event), and if the check is positive, an
element is added to the event queue requesting the evaluation of all
listeners of that event.  It is important that the event--check, as
well as the computation of the value of the event, is done in the
interrupt handler itself, as the value may depend on the hardware
state (such as the voltage on an input pin) as of that moment, and it
cannot be guaranteed that this state will not have changed by the time
the main loop retrieves the element from the event queue.  This means
that we cannot provide any strict guarantees about the resource usage
of interrupt handlers, but this is a hardware issue that is
fundamentally unsolvable in software.  Optimisations can be performed,
of course, but ultimately there are constraints on how much any
computer can do.

\subsection{Details of the event queue}
\label{sec:event_queue}
The event queue itself is such a central cog in our event-pumping
machinery that it is worth paying great attention to its form.  It is
essentially just a double-ended queue, but as it turns out, the
textbook implementation of this data structure is undesirable in
Fladuino.  Normally, one would construct a double-ended queue as a
linked list or array\footnote{In Fladuino, we would use a linked list
  rather than an array, as reserving large contiguous blocks of memory
  on the heap will often not be feasible on the memory-constrained
  Arduino platform.}, requesting additional memory from the heap as
necessary, but this runs the risk of the event--queue ballooning to
great size, especially if the program has an input source that
constantly triggers new events every few milliseconds.  Since the
stack and heap share the same memory space, we would run the risk of a
collision, causing data corruption possibly severe enough to
completely crash the program (eg. if the procedure return address on
the topmost stack frame was modified).  While we could modify the
event queue to perform a check for imminent collision whenever an
element was about to be added (and if so, ignore the event), we cannot
do the same whenever we expand the program stack, so we would run the
risk of the stack growing across the event queue and corrupting its
data, causing great harm when the main loop gets around to processing
these now invalid elements.  In conclusion, we cannot permit the stack
to grow uncontrollably.  An additional problem with using dynamic
memory is the unpredictable runtime behaviour of \texttt{malloc()},
something that is undesirable in an interrupt handler, as described in
the preceding section.

The design of our event queue thus has the following constraints:

\begin{itemize}
\item There must be a limit on the amount of memory it can occupy.
\item It must not waste too much memory.
\item Adding an element must have a predictable (and low) runtime
  cost.
\end{itemize}

The third constraint also prevents us from being too clever for our
own good, and for example storing the event-queue in the EEPROM
available on all Arduino variants in order to avoid using the same
memory as the program stack.  While an interesting idea, EEPROM writes
require unacceptable multi-millisecond delays.

Thus, our event queue consists of a statically allocated
(compile--time fixed-size) array that is not too big, and in which
element insertions have hard real-time runtime guarantees.  If an
attempt is made to insert an element into a full event queue, the
result will be a silent failure.  This is a tradeoff: as mentioned in
a previous section, we have to accept that it is possible for the
Arduino to be swamped with more work per time unit (or asked to store
more data) than it is physically able to do.  All we can do is to
design Fladuino such that the fatal error conditions are rare, and the
most common error conditions are survivable.  Stack (or heap)
corruption will in most cases result in the complete malfunction of
the program, and are thus the least desirable error case.  In
Fladuino, use of the heap is very limited (and in fact bounded by the
static maximum size of the event queue), and stack/heap corruption
will in practice only occur if the program is large enough to consume
all available memory with its stack.  The most common error case, on
the other hand, will be attempting to add an element to a full event
queue, resulting in a silent failure.  There are many cases where this
is not desirable, of course, but many reactive programs will not
experience catastrophic failure if they lose even important events,
such as button presses.  Still, we recognise that not all event loss
can be brushed aside as merely an unimportant UI deficiency, and
therefore we provide a facility, termed \textit{idle waiters}, meant
to reduce the average load on the event queue and reduce the risk of
filling it up.

\subsection{Idle waiters}

For many embedded applications, a typical workflow would be to
continuously poll an input source (such as a sensor), then adjusting
some output device based on the reading.  For example, a
line-following robot may take readings from its light sensors, then
adjust its servo--motors to ensure that it is following the line
straightly.  This can be done by simply attaching a node to a clock
that fires every millisecond, but this approach has a notable
disadvantage if many other events are being received at the same time.
The event queue may become filled with a large amount of clock events,
thus drowning out (and losing) potentially more interesting events.
In most cases, it is not a problem that the continuous polling of the
input source is in irregular intervals, but the silent loss of events
such as button presses is normally undesirable.

Thus, we provide the notion of \textit{idle waiters}, a list of atomic
subgraphs that are evaluated in a round--robin fashion whenever the
event queue is empty.  They are a useful facility for specifying
computations that should be done whenever the program is not busy with
something else.

\subsection{Posting wires}
\label{posting wires}
In the dataflow graph, atomic subgraphs can be connected by
\textit{posting wires}.  These serve to temporarily suspend execution
while the system waits for external response, thus serving in place of
blocking operations (which are not permitted in atomic subgraphs).
Conceptually, when a posting wire is encountered during evaluation of
the graph, it will send a request to an external hardware unit, wait
for a response, and then fire the destination node with the value of
the response as the input value.  Posting wires are therefore a
natural fit for solving the problem of sensor-requests that can
involve waiting an indeterminate time for the response.  For clarity,
in the following we shall refer to the external device as the
\textit{sensor}, the node preceding the posting wire as the
\textit{input node} and the node following the posting wire as the
\textit{output node}.  The phrase \textit{send a request to the
  sensor} denotes the act of requesting data from the sensor under the
assumption that a reply will be received.  Note that ``output node''
is a lossless abstraction, as several nodes may be on the receiving
end of the posting wire.  A fundamental simplifying assumption we make
in the following section is that the structure of the sensor request
is a function only of the identity of the posting wire, and is notably
not based on the value that arrived at the input node.  This rule,
which is also present in Flask, grants us much more leeway in the
implementation of posting wires.

It is not intuitively obvious what to do when a posting wire is
reached a second time, before a response has come back from the
previously sent request.  Several options present themselves:

\begin{description}
\item[Accumulate-Repeat:] If we are already waiting for a response
  from the sensor for the posting wire when a value arrives at the
  input node, we will not send another request.  Instead, we will
  increase an internal counter, and upon receiving the sensor
  response, fire the output node a number of times equivalent to the
  number of times a value arrived at the input node.
\item[Queue:] When a value arrives, queue a request to the sensor.  We
  cannot assume that all sensor hardware supports a request queue (in
  fact, we can be fairly certain that most will not), so we have to
  maintain this queue in the Fladuino runtime system.  Whenever a
  response comes back from the sensor, we fire the output node and
  check whether there are any requests left in the queue.  If so, we
  send it.  As the format of a request is a function of only the
  posting wire itself, not the incoming value, such a queue could be
  implemented as a mere integral counter, thus ignoring the problem of
  dynamically allocating memory (and potential problems resulting from
  such, as described in section \ref{sec:event_queue}).
\item[Ignore:] We can also opt not to queue or accumulate anything,
  ignore any input values sent while there is already an outstanding
  request, and fire the output node a single time upon receiving a
  reply from the sensor.  While appearing to be a lossy hack at first
  glance, we argue that it is in fact the most elegant solution, that
  its deficiencies are not important in the typical case, and that
  they can (to a degree) be worked around, if necessary.
\end{description}

Both the \textit{Accumulate--Repeat} and \textit{Queue}--strategies
suffer from \textit{clogging--propagation}, where the multitude of
inputs, greater than the sensor is capable of handling, will also
result in a large amount of activity on the output side of the posting
wire.  Especially Accumulate-Repeat suffers badly, as the receiving of
a sensor--reply will result in a potentially large amount of work, a
situation that can result in information loss if the event queue fills
up.  And as each firing of the output node will be with the same
value, it is in practice often unlikely that the repeated evaluations
are appreciably different from just a single evaluation.

The Queue strategy is more appealing, having the attractive property
that every input eventually results in a sensor request and a value
sent to the output node (barring hardware failure or --- unlikely ---
integer counter overflow).  The chief disadvantage is that there is no
way to stop the execution of the queue, should it outlast the
necessity for sensor requests.  A brief flurry of input values might
translate into requests being sent to the sensor long after desirable.
Recall that a sensor request may not necessarily translate to a
harmless, passive reading, but can be everything between reading a
simple light sensor to transmitting a sonar pulse and detecting the
environmental echo.  The Ignore strategy only causes consecutive
requests to be sent to the sensor if the input node keeps receiving
input.  Thus, a posting wire can be considered an abstraction that is
activated as long as it keeps receiving input values, and outputs a
continuous stream of sensor readings as long as it is activated.

\subsubsection{Simulating Accumulate--Repeat and Queue with Ignore}

Through clever construction of the graph surrounding the posting wire
we can mostly simulate the Accumulate--Repeat and Queue strategies
through a posting wire implementation using the Ignore strategy.  For
Accumulate--Repeat, we can connect both input and output nodes to an
\textit{accumulator node} that distinguishes between its two inputs.
When receiving a value from the input node, an internal counter will
be increased by one.  When receiving a value (the sensor reading) from
the output node, the value will be packaged up with the counter into a
tuple and sent to successors of the accumulator node, after which the
counter will then be reset to zero.  Said successors will be the nodes
that would normally follow the output node.  This does not in itself
implement the ``repeat''--portion of Accumulate--Repeat, but we have
removed the loss of information, and can thus trivially take whatever
action repeated firings of the output node would have resulted in.

\begin{figure}
  \label{accum-repeat-with-ignore}
  \includegraphics[width=0.9\textwidth]{images/accum-repeat-with-ignore}
  \caption{Simulating Accumulate--Repeat}
  \centering
\end{figure}

Simulating the Queue behaviour is significantly more complicated and
requires a somewhat clumsy use of events (see
\ref{sec:events_design}).  Values received at the input--node are sent
on to a \textit{counter node}, where we check whether we are still
waiting for the sensor to reply to a previously sent request.  If so,
we increment an internal counter and send nothing further.  When the
reply is received, by being sent to the output node, we will send a
value to the counter node, telling it to send another request to the
sensor if the counter is nonzero.  The problem in this scheme is the
wire from the output node to the accumulator node --- this graph edge
would form a cycle, something that is expressly forbidden.  On figure
\ref{queue-with-ignore}, we solve this issue by an \textit{event node}
that listens to a discrete event broadcast by the output node (the
Fladuino event system is described in detail in
\Fref{sec:events_design}).  Using the event system in such a way is
technically feasible, but violates the spirit of the design.  The
connection from output to event node can be considered to be a
particularly weak kind of posting wire --- informally, they are to
real posting wires, as software interrupts are to hardware interrupts.

\begin{figure}
  \label{queue-with-ignore}
  \includegraphics[width=0.9\textwidth]{images/queue-with-ignore}
  \caption{Simulating Queue}
  \centering
\end{figure}

\section{Framework for specifying peripheral drivers}
Arduino is a flexible system for general embedded development, with no
specific application in mind.  The Arduino platform can therefore be
connected to a diverse amount of peripheral devices, all with their
own specific functionality and programming interface.  It is thus
natural to support this diversity as a core concept of Fladuino; not
(solely) as a library of drivers for various devices, but rather as a
framework and set of tools provided to the programmer so that Fladuino
can be extended to transparently support the devices he has need of.
For demonstration, we have \fixme{not really done yet} written a
framework for programming the Pololu 3pi robot and the peripherals
connected to it (electromotors, sensors, buttons, etc.).

Furthermore, Arduino is a broad term encompassing a range of
more-or-less compatible platforms, though each of them differ slightly
in their exact capacity.  Apart from variations in such things as
memory size, they differ in amount and capability of their I/O pins.
This latter diversity is what we are most concerned with in Fladuino,
as we would like to statically check (at generation--time) the
hardware assumptions expressed in the program.  Thus, we also provide
a facility for describing the exact capabilities of a specific
Arduino-based platform, and provide default descriptions of common
Arduino--compatible such as the Arduino Duemilanove, Arduino Mega,
Arduino BT, and Pololu 3pi.

Defining the driver for each external component consist of a general
device specification in the form of a Haskell type definition, a set
of functions operating on the device type and possibly a set of event
specifications, provided the device can supports the notion of events.

\fixme{find a good example to add here}

\subsection{Platforms}
\label{capabilities}
A platform is defined by a list of \textit{logical pins}, and
free--form \textit{capabilities}, the latter being a set of strings
describing the identity or unusual qualities of the platform.  For
example, the platform definition for the Pololu 3pi robot contains a
``3pi''--capability that exists merely to express the fact that the
platform supports the quirks of the 3pi robot that cannot be expressed
through a list of pins.  Any device intended to make use of these
quirks would explicitly require the presence of this capability.

\subsubsection{The Fladuino pin model}
\label{pins}
There is no concrete distinction between analog and digital pins in
the Atmel microcontroller that lies at the heart of all Arduino
platforms --- they are just subsets of the single set of numbered pins
that differ in their capabilities.  Arduino, however, drives a hard
distinction between analog input and general-purpose digital pins, in
particular enumerating them in different sequences (there is a digital
pin 0 distinct from analog pin 0).  This notion is fully integrated
and supported in Fladuino; in fact there is no way to directly address
pins by the name they are known by to the Atmel microcontroller.  We
identify three layers of pin abstraction, each building on the one
below it:

\begin{description}
\item[Arduino pins] are what a normal user of Arduino will be familiar
  with.  They are identified by a \textit{pin type} (digital or
  analog-input) and a number.  Analog-input pin 0 and digital pin 0
  are not the same pin.  This is the layer of abstraction that devices
  work at.
\item[Logical pins] are a simplification of Arduino pins, where the
  Arduino pin abstraction is mapped to a single enumerated sequence.
  This mapping is defined specifically for each platform; for example,
  Arduino digital pin 0 will equal logical pin 0 on both the
  Duemilanove and Mega platforms, but analog pin 0 equals logical pin
  14 and 54, respectively.  A typical user of Fladuino will never have
  to go below this level of abstraction, and will only have to
  interact with it if he is defining a new platform.
\item[Hardware pins] are the physical pins connected to the
  microcontroller.  They are only interacted with in the
  implementation of the Arduino and Fladuino supporting libraries.
  The Arduino libraries themselves define the mapping from logical to
  hardware pins, and adding a new mapping is a significant task.
\end{description}

This choice of abstraction is not as obvious as it may appear: we do
lose a non-nil amount of expressive power by restricting ourselves to
the interface provided by Arduino, rather than permitting complete
exploitation of the capabilities of the microprocessor.  Yet for the
following reasons, we believe we made the right choice:

\begin{itemize}
\item The software abstraction provided by Arduino exposes a uniform
  interface to a range of different hardware implementations.  These
  implementations share a similar software interface to their shared
  functionality, thus making porting between them easy.  In contrast,
  not even pin numbers are necessarily identical between the
  microcontrollers found across the range of supported platforms.  We
  could solve this by defining our own mapping between abstract pins
  and hardware pins (based on the chosen platform), but we see no
  advantage to this approach over adopting the mapping already defined
  by Arduino.
\item A shared pin abstraction makes it easier for Fladuino--generated
  programs to use existing Arduino libraries.
\item The pin identifier sequences defined by the Atmel
  microcontrollers are not particularly intuitive when mapped to the
  physical layout of the Arduino boards.  They are fragmented and with
  large jumps.
\end{itemize}

Abstractions aside, each pin is not only defined by its number, but
also by a set of \textit{capabilities}, very much like the ones that
cover the entire platform.  For example, a given pin may support such
things as \texttt{pin--change interrupts} (triggering an asynchronous
signal when the input value on the pin changes) or \texttt{pulse-width
  modulation} (analog output).  Many hardware devices only work when
attached to pins with special capabilities --- for example, a
push--button must be attached to a pin supporting interrupts --- and
the capability notion allows us to statically sanity--check any used
devices for such requirements at generation--time.

\subsection{Devices}
We use the term \textit{device} for any form of peripheral that can be
connected to an Arduino board, e.g. buttons, electromotors and
potentiometers.  The definition of a device consists of a list of
\textit{usages}, each describing a discrete reservation of some
hardware resource, and a unique identifier.  A device can be
parametric --- in fact, most are --- in for example the I/O pins that
it is attached to.  As a concrete example, the device describing a
plain digital output pin is parametric in the form of the single
integer parameter denoting the number of the digital pin it
represents.

The notion of a usage deserves further elaboration: apart from being a
facility for statically finding resource usage conflicts between
devices, they are also a way to configure the starting state of the
Arduino board.  We define three different kinds of usages, two of which
reserve exclusive access to the hardware resource that they refer to:

\begin{description}
\item[Digital pin usage] is an expression of exclusive access to one
  of the digital pins on the Arduino board.  If any other device has a
  usage involving the same pin, this will be reported as an error at
  generation--time.  A digital pin usage also specifies a list of
  capabilities that must be provided by the indicated pin.
  Additionally, a digital pin usage can have one of three types:
  \begin{description}
  \item[Digital output,] in which case the usage will also have to
    specify a starting value (\texttt{HIGH} or \texttt{LOW}) on the
    pin.
  \item[Digital input]
  \item[Analog output,] in which case a starting value must be
    specified in the range $[0,255]$.  Note that this ``analog'' value
    is, of course, implemented via PWM (see \ref{pwm}), and the
    capability ``PWM'' should thus be required of the pin.
  \end{description}
\item[Analog input pin usage] denotes exclusive access to a specified
  analog input pin.  The usage also specifies a list of capabilities
  that must be provided by the indicated pin.
\item[Capability requirement usage] is a dependency on the presence of
  a given \textit{platform capability} (see \ref{capabilities}).  In
  contrast to the pin usages, this dependency is not exclusive.
\end{description}

Some measure of power is lost by restricting devices to exclusive
access to pins.  However, the fragility of having devices share these
I/O pathways require detailed knowledge of exact device behaviour
anyway, in order to ensure that they will not be incompatible.  Given
this knowledge, the user can merely connect several physical devices
to the same IO pin (for example, multiple diodes to the same digital
output pin) and use a single logical device in the Fladuino program to
interact with them.  Indeed, this solution is mostly satisfactory, as
long as the devices are (almost) identical in their interface.

See \Fref{sec:pushbuttondef} for an example of how to define a device
via these abstractions.

\subsection{Events}
\label{sec:events_design}
A central aspect of any embedded system is responding to external,
asynchronous events.  The hardware feature enabling this functionality
--- asynchronous interrupts --- is primitive and hard to use, leading
us to define a high--level interface, closely interconnected with the
device abstraction, with which we can describe reactions to stimuli in
terms that are closer to the problem domain of the application.  In
the following, we distinguish between \textit{triggering an
  interrupt}, which is the hardware executing the interrupt handler,
and \textit{triggering an event}, which is Fladuino arranging for the
execution of any event listener operators with the event as the input
value.

All events have a static type and value, which is used to distinguish
between them at generation--time, and an event may carry a data
\textit{payload} at runtime.  A critical piece of static information,
that can be found in most (if not all) events, is the device that the
event is associated with.  All events stem from external sources of
input, and a given event is such intrinsically linked to some specific
device, though it is possible to define events that are not connected
to Arduino's notion of a logical device --- for example, by hardcoding
the I/O pins directly into the implementation of the event.  In this
section, however, we shall assume that all events are connected to a
device.  Not all events have payloads (or rather, some events have
payloads of the information--less type \textit{unit}): an event
indicating the press of a pushbutton has no payload, and contains no
information apart from the static event value itself (which indicates
the exact button that was pressed), while an event indicating that a
piece of sensor hardware has finished taking a reading may contain the
reading data as the payload.

As an example, assume that $p_1$ is a pushbutton device connected to
digital pin 1, $d_2$ a diode connected to pin 2, and $\sigma(e,d)$ a
dataflow graph node that fires whenever the given device $d$ triggers
event $e$.  We can then construct a dataflow graph such as
$\sigma(pushdown,p_1) \rightarrow toggle(d_2)$, connecting the input
of pressing a button to the action of toggling the state of a diode.

In the definition of an event, a list of Arduino pins (see \ref{pins})
indicates which pin--change interrupts might trigger the event.
Additionally, two object--language functions are defined: a
\textit{predicate}, for checking whether a given pin--change interrupt
is actually should actually cause the event to trigger, and a
\textit{value function}, that calculates the payload (if any) of the
event.  This yields total control to the event implementor, at the
cost of having to check all events possibly triggerable by an
interrupt, whenever the interrupt is triggered.  This can potentially
be problematic: as mentioned above, it is highly undesirable to spend
too much time in an interrupt handler, but we cannot defer execution
of either predicate or value function, as the result of those may
depend on highly volatile dynamic state of the Arduino.  Indeed;
merely the minute delay between the triggering of the interrupt, and
the execution of a some predicate or value function, may change this
state.  On the upside, the time spent in the interrupt handlers will
have a static upper bound defined by the number of events used in the
program, thus making problems of this sort likely to appear during
initial testing, and not lay dormant until after deployment.  Of
course, this bound is dependent on the implementation of the
user--defined predicate and value functions --- if these have
unpredictable runtime behaviour (or worse: block), we cannot guarantee
anything.  See \Fref{sec:pushbuttondef} for example code.

Events initiate dataflow at nodes marked as \textit{listeners} for the
specific event.  Design--wise there is nothing that prevents these
listeners from being successors of other nodes in some atomic
subgraph, but have not been able to identify a use for such a
structure during our work.  As a result, we generally consider an
event--listening node to have no way of firing except for the
triggering of one of the events that the node is listening for.  A
single node can listen to multiple different events (though again, we
have not been able to identify a practical need), as long as the
payloads are of the same type.

\chapter{Implementation}

The essence of Fladuino can be condensed to a single, conceptually
simple problem: translate a high-level functional reactive program to
a form suitable for execution on the Arduino platform.  We have chosen
to stop a step short, and merely generate C code meant for further
compilation through an Arduino-specific compiler.  We have no need of
the additional power we would gain through generating our own machine
code, and the additional amount of work required would be very large.
Flask chooses the same approach, in that it produces NesC--code for
running on sensor motes, likely for the same reasons.

\section{Dataflow translation}
\label{dataflowtranslation}
At their heart, both Flask and Fladuino--programs consist of an
acyclic dataflow graph.  A core part of the system involves the
translation of this high-level description of the passage of data into
the procedural target environment.  Fladuino adopts Flask's
implementation almost verbatim, the details of which will be explained
within this chapter.

As in Flask, the graph is divided into \textit{atomic subgraphs},
sections that can be executed without blocking

\subsection{Translation of a simple dataflow graph}

A set of nodes (dataflow operators) connected by a set of directed
graph edges (wires) make up the entirety of the dataflow graph. Each
wire is associated with type information regarding the values that
will be passed along it.  Some dataflow operators have no predecessor
and exist solely as entry points for data (they can be triggered by
outside events, such as device or timer interrupts), while others have
no successors and function as data sinks.  It is required that the
graph is acyclic, something that is enforced by every operator being
uniquely identified by (among other things) its predecessor(s).  A
stream operator can have multiple distinct input, but only a single
output, though this output can be split so as to send the same output
value to any number of successors.

For every operator $o$ in the dataflow graph, a set of unary
functions $o\_in_n()$ and a unary function $o\_out()$ will be
generated.  The arrival of a value $v$ at $o$ will be implemented by a
call $o\_in_n(v)$, where the exact choice depends on the wiring of the
graph.  In the typical case, even when several wires leads to a single
stream operator, there will be only a single such $o\_in_n()$
function\footnote{In fact, multiple ``in'' functions are only
  necessary for operators such as \texttt{szip}, which works by
  waiting until it has received two values $x, y$ from its two direct
  predecessors, after which it sends them along to its successors as
  the tuple $(x,y)$ --- in this case, the two functions will need
  different types and semantics, as there it is not required that $x$
  and $y$ have the same type.}.  Depending on the specific semantics
of $o$, a value $v'\equiv f(v)$ (where $f()$ represents the
computation done by $o$, the result may not even depend on $v$ at all)
may be propagated to the successors of $o$.  In this case,
$o\_in_n(v)$ will call $o\_out(v')$, the implementation of which will
feature the calls $\forall s \in S(o). s\_in(v')$, where $S(o)$ is the
set of all successors of $o$.

$o\_in()$ is generated directly by the implementation of the specific
dataflow operator, but $o\_out()$ is automatically created by Fladuino
during code generation.  The utility of this division is that the
implementation of a dataflow operator does not feature tedious
duplication of the value propagation machinery, yet as it is not
required that $o\_out()$ is called at all, each dataflow operator can
still make its own choice whether to propagate a value or not.

It is worth nothing that a value need not contain any information
apart from its existence; \texttt{()} is perfectly valid as a signal.



\subsection{Implementation of posting wires}

\subsection{On blocking and busywaiting}

\section{User--extensible abstractions with typeclasses}

\subsection{Defining new devices}

\subsection{Defining new events}

\section{Something about arduino external interrupt handling}
\fixme{Lav rigtigt overskrift.}

The default behaviour of the Atmega chip platform when interrupts occur is that
the GIE (Global Interrupt Enable) bit\footnote{which is the L-bit in the SREG
  (Status Register)} is cleared and thus all interrupt are disabled. The GIE bit
is automatically set again when the IHF (Interrupt Handler Function) returns,
using the RETI instruction. The software running on the chip could however
enable the GIE bit when the IHF is called, thus allowing nested interrupts. If
interrupts triggers when GIE is disabled, their individual flag bits is set and
when GIE is enabled again those interrupts will trigger in the order the flags
is located in the registers, and not necessarily in the order the interrupts
happened. When GIE is disabled and the same interrupt happens multiple times,
only the first one set the flag and thus it is not possible to know how many
times the interrupt actually occurred \cite[Section 4.7 page 14]{atmel8p}

\subsection{Types of interrupts}

The Atmega chip support two types of interrupts. The sophisticated INT0..1 pins
and the simple PCI0..2 which controls the PCINT0..23 pins. The sophisticated
interrupts supports low level, logical change, falling edge and rising edge,
though Fladuino only supports the logical change on any of the interrupt
types. These interrupts are triggered if the INT0..1 bit is enabled in the
EIMSK (External Interrupt Mask) Register and the GIE bit is set.

The simple interrupts only support logical change and doesn't directly support
separate IHF's for each PCINT pins but only for each of the three PCI0..2. These
interrupts are triggered if the GIE bit is set, either of the PCIE0..2 bits is
enabled in the PCICR (Pin Change Interrupt Control Register) and any of the
PCINT0..7, PCINT8..14, PCINT16..23 bits respectively, is enabled in the
PCMSK0..2 (Pin Change Mask) register. As any logical change to any of the
PCINT0..7 pins will only trigger the PCI0 IHF, this function must then see which
of the enabled PCINT0..7 pins that has changed its value since last time, by
keeping a track of their state, and then trigger the defined IHF for each of the
changed pins and so fourth for all the PCI0..2. An example of this can be seen
on the Arduino Playerground
\footnote{\url{http://www.arduino.cc/playground/Main/PcInt}, last checked 23rd
  June 2009} which have been modified to work on all the supported platforms in
Fladuino system \cite[Section 10 page 70]{atmel8p}.

\chapter{Example programs}

\textit{Beskrivelse af vores fedeste eksempelprogrammer: 3pi,
  binærtæller etc. og hvorfor det er smart.}

\section{Building on the abstractions}

In the following sections different Haskell code is shown as examples of how
different Fladuino interfaces, which utilises various parts of framework such as
events, are constructed. For brevity, module imports has been omitted in all the
examples.

\subsection{Defining a pushbutton}
\label{sec:pushbuttondef}

The following is a definition of the Fladuino interface for a simple digital
pushbutton. First the type constructor \texttt{PushButton} is defined with the
data constructor \texttt{PushButton Integer} where the \texttt{Integer} type
defined which pin the physical device is connected to. 

\begin{verbatim}
data PushButton = PushButton Integer
                  deriving (Eq, Show)
\end{verbatim}

\noindent
Then a \texttt{Device} instance declaration on \texttt{PushButton} is done
which registers the specified digital pin as being \texttt{DigitalInput} and
requiring interrupt functionality. This assures that the specific pin has
interrupt functionality and that no other devices using this pin requires
\texttt{DigitalOutput} otherwise an error will occur.

\begin{verbatim}
instance Device PushButton where
    usages (PushButton pin) = [DPinUsage pin ["interrupt"] DigitalInput]
\end{verbatim}

Since logical change interrupts occurs twice on a pushbutton (when pushed and then when
released) it is easy and god abstraction to define a \texttt{PushButtonPressEvent}  and a
\texttt{PushButtonReleaseEvent}, and thus the two type constructors is defined

\begin{verbatim}
data PushButtonPressEvent = PushButtonPressEvent PushButton
                            deriving (Eq, Show)
data PushButtonReleaseEvent = PushButtonReleaseEvent PushButton
                              deriving (Eq, Show)
\end{verbatim}

\noindent
Next a \texttt{Event} instance declaration on the two \texttt{PushButton} events
is needed. The \texttt{Event} type class needs definitions for the operations
\texttt{setupEvent} and \texttt{interruptPins} which are both self
explanatory. To distinguish these two events from each other, the value on the
pin associated with the physical pushbutton is read and if the value is
\texttt{HIGH} it is treated as a press event and if it is \texttt{LOW} it is
treated as release event.

\begin{verbatim}
instance Event PushButtonPressEvent () where
    setupEvent e@(PushButtonPressEvent (d@(PushButton pin))) = 
     do addDevice d
        pv <- statevar d "press_predicate" 
        let v = H.Var (mkName pv)
        addCImport pv [$ty|() -> Bool|] [$cexp|$id:pv|]
        addCFundef [$cedecl|int $id:pv () {
                              return (digitalRead($int:pin) == HIGH);
                            }|]
        return $ mkEvent e Nothing (Just v)
    interruptPins (PushButtonPressEvent (PushButton pin)) = [DPin pin]


instance Event PushButtonReleaseEvent () where
    setupEvent e@(PushButtonReleaseEvent (d@(PushButton pin))) = 
     do addDevice d 
        pv <- statevar d "rel_predicate" 
        let v = H.Var (mkName pv)
        addCImport pv [$ty|() -> Bool|] [$cexp|$id:pv|]
        addCFundef [$cedecl|int $id:pv () {
                              return (digitalRead($int:pin) == LOW);
                            }|]
        return $ mkEvent e Nothing (Just v)
    interruptPins (PushButtonReleaseEvent (PushButton pin)) = [DPin pin]
\end{verbatim}

With this definition, we can define programs such as:

\begin{verbatim}
onEvent (PushButtonPressEvent $ PushButton 3) >>> (toggle $ diode 13 True)
\end{verbatim}

This program will toggle the state of a diode connected to digital pin
13 (a default device on almost all Arduino boards) whenever the
pushbutton attached to digital pin 3 is pressed.

\subsection{Defining a potentiometer}

Here the 

\begin{verbatim}
data Potentiometer = Potentiometer Integer
                     deriving (Eq, Show)

instance Device Potentiometer where
    usages (Potentiometer pin) = [APinUsage pin []]

instance AnalogInputDevice Potentiometer where
    genReadCode (Potentiometer pin) resultvar = [[$cstm|$id:resultvar = analogRead($int:pin);|]]
\end{verbatim}

This allows programs to pull value of the potentiometer as this one

\begin{verbatim}
idle >>> (valueOf $ Potentiometer 0) >>> smap [$exp|(/4)|] >>> (setValue $ AnalogOutputPin 10 0)
\end{verbatim}

The reason why the pulled value is devided by 4 is that the Atmega chip by
default returns values between 0 and 1024 when doing analog reads but can only
write values between 0 and 256 unless explicitley changed. The mapping 0 to 1024
when reading analog values is from GND to AREF which is nomally 0v and 5v
respectively though AREF can be explicitley changed.

\subsection{Defining a servomotor}

\subsection{Defining a new platform}

\subsection{Defining Saturn V--nozzle control}

\chapter{Evaluation}
\begin{itemize}
\item Is this for any practical use?
\item What was easy and hard when writing the example-programs?
\item How does the example-programs compare to similar programs
  written directly in C? More or less code? More or less debugging?
\end{itemize}

\chapter{The Fladuino Future}
\textit{Hvad vi ikke har, eller hvad der skal arbejdes videre med. }

Lidt idéer:
\begin{itemize}
\item Find på noget bedre end Red 
\item Se om man kan få lavet en instans af Arrow-typeklassen, så man
  kan bruge Yampas Arrow-syntax.
\item Bedre fejlmeddelelser (Pt. udskrives syntaxtræet efter parse af
  quasiquotet tekst ved fejl. Dette skal dog rettes i
  Quasiquotation-modulet eller måske kræver det speciel integration
  med compileren)
\item \textit{(Bør vi måske satse på at få med inden aflevering:)}
  Gør det endnu nemmere at skrive drivers til nye
  robotter. F.eks. så man kun skal angive en typeklasse instans der
  foræller om robottens fysiske egenskaber (afstand mellem hjul etc.)
  og hvilke funktioner der skal kaldes for at styre hjulenes
  hastighed. Hvorefter man så får adgang til en række generelle
  styringsabstraktioner.
\end{itemize}

\chapter{The past}
Discussion about related robot programming tools (Frob, Yampa, Atom,
Lustre, etc.).

\chapter{Conclusions}
\textit{Opsummering på hvad vi har opnået}

Ideas for this section:
\begin{itemize}
\item Modified Flask, so it generates Arduino targeting C-code.
\item Added abstractions for Events, Devices, Platform specification etc.
\item Written a small framework/driver-library for the 3pi.
\item Small note on example programs
\item Comparison with Frob, Atom etc.
\end{itemize}


\bibliographystyle{bibliography/theseurl}
\bibliography{bibliography/rapport}

\appendix

\chapter{Small guide to Arduino}

\fixme{We should update the $\backslash$ texttt to uses the listings
  inline formatting instead when ever c code is listed.}

Description of Arduino from the official
website\footnote{\url{http://www.arduino.cc/} downloaded the 28. of April 2009 at 15:16}:
\begin{quotation}
  Arduino is an open-source electronics prototyping platform based on
  flexible, easy-to-use hardware and software. It's intended for
  artists, designers, hobbyists, and anyone interested in creating
  interactive objects or environments.

  Arduino can sense the environment by receiving input from a variety
  of sensors and can affect its surroundings by controlling lights,
  motors, and other actuators. The microcontroller on the board is
  programmed using the Arduino programming language (based on Wiring)
  and the Arduino development environment (based on
  Processing). Arduino projects can be stand-alone or they can
  communicate with software on running on a computer (e.g. Flash,
  Processing, MaxMSP).
\end{quotation}

\begin{nonfloatingfigure}
  \centering
  \includegraphics[scale=0.5]{images/ArduinoDuemilanove}

  \caption{Picture of a Arduino Duemilanove. Picture is taken from the Arduino
    homepage: \url{http://arduino.cc/en/Main/ArduinoBoardDuemilanove}.}
  
\end{nonfloatingfigure}

There are different kinds of Arduino boards. All are based on
different ATmega processors from Atmel. The older boards used serial
communication while the newer ones are connected to the computer
through a USB cable, but still using the same serial communication
protocol (i.e. serial through USB). The USB cable also serves as a
power supply.



We will describe the Arduino Duemilanove board we have used, in the
sections that follow, but most information will apply to
the other Arduino boards as well.

\section{Pins}
The Arduino board can connect to several external components through
diverse input and output pins. The pins are split in three physical sections on
the board \textit{power}, \textit{analog in} and
\textit{digital}. Before any IO can happen on a pin, it's mode must be
set. The mode of a pin defines if it is used to read input or
write output. The mode is set by the function \texttt{void pinMode(int
  pinnumber, int mode)} where \textit{pinnumber} is a number between
0-5 for analog and 0-13 for digital and \textit{mode} is either of the constants
\texttt{OUTPUT} or \texttt{INPUT}.

\subsection{Power pins}
% http://arduino.cc/en/Reference/Board?from=Guide.Board
\begin{itemize}
\item Reset: Resets the board when connected to ground.
\item 3V3: Constant 3,3v output
\item 5v: Constant 5v output
\item Gnd: Two ground pins
\item Vin: The voltage supplied by the external power supply.
\end{itemize}

\subsection{Digital pins}

There are 14 digital input and output pins. Six of them can also be
used to generate analog output by PWM (Pulse Width Modulation). It's
possible to read a boolean value \texttt{HIGH} and \texttt{LOW} by the
following function \texttt{bool digitalRead(int pinnumber)} where
pinnumber is a number between 0 and 13. It's possible to write a
boolean value by the following function \texttt{void digitalWrite(int
  pinnumber, int value)} where pinnumber is a number between 0 and 13
and value is either \texttt{HIGH} or \texttt{LOW}.

\subsection{Analog input}
There are 6 analog input pins. It's possible to read a voltage level
from each of them using the function \texttt{int analogRead(int
  pinnumber)} where \textit{pinnumber} is a number between 0 and 5
indicating which pin to read from. The result is given as an integer
in the range from 0 to 1023. It's possible to write a voltage level
(PWM wave, explained below) by the following function \texttt{void
  analogWrite(int pinnumber, int value)} where \textit{pinnumber} is
one of (3,5,6,9,10,11) which is located among the 14 digital pins and
\textit{value} is an integer in the range from 0 to 255. The reason
why the 6 analog output pins is located among the digital IO pins is
that the platform uses PWM to generate the desired voltage level.

\subsubsection{PWM}
\label{pwm}
A description of PWM from the Arduino website follows:
\footnote{\url{http://www.arduino.cc/en/Tutorial/PWM} downloaded the
  28. of April at 17:14}

\begin{quotation}
  Pulse Width Modulation, or PWM, is a technique for getting analog
  results with digital means. Digital control is used to create a
  square wave, a signal switched between on and off. This on-off
  pattern can simulate voltages in between full on (5 Volts) and off
  (0 Volts) by changing the portion of the time the signal spends on
  versus the time that the signal spends off. The duration of "on
  time" is called the pulse width. To get varying analog values, you
  change, or modulate, that pulse width. If you repeat this on-off
  pattern fast enough with an LED for example, the result is as if the
  signal is a steady voltage between 0 and 5v controlling the
  brightness of the LED.

  In the graphic below, the green lines represent a regular time
  period. This duration or period is the inverse of the PWM
  frequency. In other words, with Arduino's PWM frequency at about
  500Hz, the green lines would measure 2 milliseconds each. A call to
  \texttt{analogWrite()} is on a scale of 0 - 255, such that
  \texttt{analogWrite(255)} requests a 100\% duty cycle (always on),
  and \texttt{analogWrite(127)} is a 50\% duty cycle (on half the
  time) for example.

  \begin{nonfloatingfigure}
    \centering
    \includegraphics[scale=0.6]{images/pwm}

    \caption{How 0\%, 25\%, 50\%, 75\% and 100\% PWM is measured by a
      oscilloscop. Where Each vertical green line indicates the duty
      cycle}
    \label{fig:pwm}
  \end{nonfloatingfigure}
  
  \fixme{Better figure text and figure should be non-floating. Jesper
    has a solution to this in his old Graphics report}

  Once you get this example running, grab your Arduino and shake it
  back and forth. What you are doing here is essentially mapping time
  across the space. To our eyes, the movement blurs each LED blink
  into a line. As the LED fades in and out, those little lines will
  grow and shrink in length. Now you are seeing the pulse width.
\end{quotation}



\section{Timer Interrupts}

\fixme{fix text to support new heading: timer interrupts}

The ATmega168/ATmega328 processors has three different hardware
timers. One of them (timer 0) is used by Arduino software to provide a
\texttt{millis()} function that gives us the amount of milliseconds
since the timer started and a \texttt{delay} function that actively
holds the processor occupied for a given time period. Timer 0 and 2
uses 8 bit registers and timer 1 uses a 16 bit register. This
effectively means that timer 0 and 2 can't count to more than 255
whereas timer 1 can count to 65535. The registers is incremented at
the speed of the processor, in this case 16MHz, divided by a prescale
factor which can be either of 1 (no scaleing), 8, 64, 256, 1024 for
timer 0 and 1 and either of 1, 8, 32, 64, 128, 256, 1024 for timer
2. The reason why timer 0 and 1 has 2 less prescale factors is that
they can be wired up with an external clock source and setup to
trigger on a falling or rising edge. With a prescale of 256 the
counter is incremented at a rate of $\frac{16000000\mathrm{Hz}}{256} =
62500\mathrm{Hz}$, which makes the counter overflow at a rate of
$\frac{16000000\mathrm{Hz}}{255*256} = \frac{62500\mathrm{Hz}}{255} =
245.1\mathrm{Hz}$ (pr second). This applies to all three timers where the only
2 variables are the prescale and the size of the counter register.

The three timers modes of operation is \texttt{Normal},
\texttt{CTC}(Clear Timer on Compare match), \texttt{Fast PWM},
\texttt{Phase Correct PWM} where \texttt{Normal} and \texttt{CTC} are
the ones of interrest:

\begin{description}
\item[\texttt{Normal}] mode counts from a optionally specified counter
  value (initially default set to 0) and increments until it reaches
  the maximum value 255 where it overruns, restarts from 0, the
  interrupt is triggered and incrementation of the counter
  restarts.

\item[\texttt{CTC}] mode has a predefined top value and optionally
  specified counter value (initially default set to 0). When the
  counter reaches the defined top value it is cleared to 0, the
  interrupt is triggered and incrementation of the counter
  restarts. This gives better resolution of the counter and thus more
  flexibility than the \texttt{Normal} mode.
\end{description}

The modes of operation is described in detail in the processors
datasheet, section 12.7 ``Modes of Operation''.

\subsection{PWM generation}

PWM is generated from these three timers. Pin 5 and 6 are connected to
timer 0, 9 and 10 to timer 1 and pin 3 and 11 to timer 2. This means
that the frequency of the PWM signal is controlled by the speed of
these counters which again is determined by the prescale. When an
\texttt{analogWrite(pinnumber, value)} is executed, the value is
compared against a value in a 8-bit counter (one associated to each
timer). When the counter is less than the specified value it outputs
\texttt{HIGH} on \textit{pinnumber} and \texttt{LOW} otherwise. This
generates a square wave with a duty cycle of 50\% since it is
\texttt{HIGH} on counts $0 \ldots 127$ and \texttt{LOW} on counts $128
\ldots 255$. Since Arduino uses timer 0 for the various time related
functions, the prescale on this timer can't be changed unless this
feature are not to be used. Also because of this the duty cycle of pin
5 and 6 is not exactly the same as the other 4 pins.

\fixme{Interference problems with the PWM output pins.}  

\section{External Interrupts}

Essentially all the pins on the Arduino board supports external
interrupts, though only digital pins 2 and 3 is supported directly by
the Arduino code via the function \texttt{void attachInterrupt(int
  interruptpin, void (* userfunc)(void), int mode)} where
\textit{interruptpin} is either 0 or 1, \textit{userfunc} is the user
function to call when the interrupt triggers and \textit{mode} is one
of \texttt{LOW}, \texttt{CHANGE}, \texttt{RISING} or
\texttt{FALLING}. The \textit{mode} property is special for these two
external interrupt pins, as the other pins only support the
\texttt{CHANGE} mode. The full descriptions of the modes is in the
datasheet of the processor section 10.2.1 ``EICRA - External Interrupt
Control Register A''. To set up external interrupts on the other pins
the user \textit{ckiick} has added an usable header file to the Arduino
playground\footnote{\url{http://www.arduino.cc/playground/Main/PcInt}
  taken 28th of April 2009 at 16:45} also containing an
example of how it works. This header file defines a function
\texttt{void PCattachInterrupt(int interruptpin, void (*
  userfunc)(void), int mode)} where the only difference is that the
\textit{mode} property only supports \texttt{CHANGE}.



\section{Arduino BT}

The Arduino BT board is different from all the other Arduino boards since it
comes with a Bluegiga WT11 Bluetooth chip (from now refered to as WT11 chip)
instead of the USB mount. This means that the board can be programmed and
communicated with through a wireless connection. The communication protocol is
still RS232 so besides the wireless communication nothing is different about
this.

Other main differences as listed at the Arduino
homepage\footnote{\url{http://arduino.cc/en/Main/ArduinoBoardBluetooth} taken
  16th of May at 23:57}:

\begin{itemize}
\item The use of a DC-DC convertor, allowing the board to be powered with a
  minimum of 1.2 V, but with a maximum of 5.5 V. \textbf{Higher voltages or
    reversed polarity in the power supply will kill the board.}

\item A surface-mounted ATmega168 (as with the Arduino Mini). This doubles the
  amount of space available for your sketches and adds three more PWM pins and
  two more analog inputs.

\item Pin 7 is connected to the reset pin of the bluetooth module. 

\item Only use serial communication at 115200 baud; this is the speed that the
  module has been configured to use.
\end{itemize}

As stated digital pin 7 is reserved and connected to the WT11 chip's reset
pin. This means that if a program does a \texttt{digitalWrite(7, HIGH)} and
shortly after does a \texttt{digitalWrite(7, LOW)} the WT11 chip will be
reset. This will however not restore the factory settings of the WT11 chip as
all changes to settings are persistent.

In the below sections it is assumed that the user is using a Unix-like operating
system with Bluetooth associated packages installed, unless otherwise noted.

\subsection{Powering through a USB  cable}

As the board doesn't have the USB mount it is not able to draw power from the
host as most of the other Arduino boards has. This means that the board must be
powered by an external power supply (E.g. batteries). Powering the board when
next to a computer can however still be done through a modified USB cable. As a
standard USB cable consists of 4 wires

\begin{table}[h!]
  \centering
  \begin{tabular}{|c|c|c|}
    \hline
    Contact number & Signal name & Wire colour \\ \hline
    1 & VCC & Red \\ \hline
    2 & D- & White \\ \hline
    3 & D+ & Green \\ \hline
    3 & GND & Black \\ \hline
  \end{tabular}
  \caption{USB Connector Termination Data. Described in the USB 2.0
    specification\cite{usb20} Table 6-1 ``USB Connector Termination Assignment''}
  \label{tab:ArduinoBT:Connector_Termination_Data}
\end{table}

According to the USB 2.0 specification\cite{usb20} Table 7-7 ``DC Electrical
Characteristics'' the VCC wire supplies a minimum of 4.75v and a maximum of
5.25v which is no problem as the Arduino BT board can handle up to 5.5v and as
low as 1.2v. There is however always a slight possibility of faulty equipment
which could damage the board.

The wire colours for a standard USB 2.0 cable are defined in the
specification\cite{usb20} Figure 6-2 ``USB Standard Detachable Cable Assembly''
but it is not all manufactures that comply with this.

To construct the USB power cable all that needs done is to cut off the connector
opposite of the Standard-A connector, which is the one that fits in the
computer. Next strip off the a few cm of the PVC jacket and the copper/aluminium
shield on the cable so the four wires are free. Then cut away the 2 data wires
(green and white) and strip off 0.5cm of the VCC and GND wires insulations (red
and black). Now the two stripped wires can be connected to the Arduino BT board
through the power socket (X1). Remember not to reverse the polarity when
connecting the two wires, ore else the board cold be damaged.

\subsection{Binding with the device}

Before the board can be programmed or communicated with, it must be binded with
a host. To bind with a Bluetooth device, its MAC address is needed. A list of
names and MAC addresses of all Bluetooth devices in the area can be found with
the following command:

\begin{verbatim}
hcitool scan
\end{verbatim}

A factory Arduino BT board is always named \textit{ArduinoBT} and has the PIN
12345. There are at least 2 ways of handling Bluetooth PIN authentication. The
simplest ways is to put the PIN and nothing else in the file
\textit{/etc/bluetooth/pin} before binding with the device this however can be
complicated when binding with multiple devices with different PIN as the file
can only contain a single PIN at a time. The other way is to use
\texttt{bluetooth-applet} (Gnome) or \texttt{kbluetooth4} (KDE), which both
places a icon in the tray and queries the user for a PIN when required by the
Linux Bluetooth stack.

Whichever way is used, the host can now bind with the Arduino BT board with the
following command

\begin{verbatim}
rfcomm bind rfcommX xx:xx:xx:xx:xx:xx 1
\end{verbatim}

where \texttt{rfcommX} is the desired host device that is to be used ex
\texttt{rfcomm0}, \texttt{xx:xx:xx:xx:xx:xx} is the boards MAC Address and
\texttt{1} is the channel to be used. A factory Arduino BT board has only
enabled \texttt{SSP} (Serial Port Profile) and thus this is located on channel
1. It is possible to query which Bluetooth profiles the Arduino BT board exposes
by the following command

\begin{verbatim}
sdptool browse xx:xx:xx:xx:xx:xx
\end{verbatim}

To find the channel, just locate \texttt{SPP} in the returned list and see what
channel the \texttt{rfcomm} protocol is associated with.

\subsection{Important program setup}

When creating a program for the Arduino BT it is important to remember a few
things in the \texttt{setup()} function. This is to ensure that the WT11 chip is
always configured when the program starts. The WT11 chip remembers its settings
even if it loses power. This means that if the settings are change at some point
of the program execution then at least the basic settings will be set to a known
default when the program is restarted. It is however still possible to change
the settings of the WT11 chip so it won't accept connections from any
hosts. This is addressed in the below sections.

\begin{table}
  \centering
\begin{verbatim}
  pinMode(7, OUTPUT);
  Serial.begin(115200);
  digitalWrite(7, HIGH);
  delay(10);
  digitalWrite(7, LOW);
  delay(2000);

  Serial.println("SET BT PAGEMODE 3 2000 1");
  Serial.println("SET BT NAME ARDUINOBT");
  Serial.println("SET BT ROLE 0 f 7d00");
  Serial.println("SET CONTROL ECHO 0");
  Serial.println("SET BT AUTH * 12345");
  Serial.println("SET CONTROL ESCAPE - 00 1");
  Serial.println("SET CONTROL BAUD 115200,8n1");
\end{verbatim}
  \caption{asd}
  \label{tab:ArduinoBT:Initial_Setup_code}
\end{table}


The WT11 chip is connected to the Atmega chip by its RX and TX lines, which
means that communication is done through Arduino's serial communication
capabilities. The WT11 chip communicates at a baud rate of 115200 thus it is
important to use this speed in the \texttt{Serial.begin} function. Even though
the WT11 chip's iWRAP firmware can be changed to use another baud rate, this is
not recommended and will most likely not work. The name that should be visible
when searching to Bluetooth devices is configured by the \textit{SET BT NAME}
command, and the PIN is configured by\texttt{SET BT AUTH *} command. Other iWRAP
commands and their definitions can be seen in the ``iWRAP User Guide''.

\subsection{Communication without Bluetooth}

If the WT11 chip is configured in a way such that it refuses connections or in
some other way that the Atmega chip cannot be programmed, you need to reset to
factory settings (by doing a firmware update) or by changing the individual
settings back to something that works. 

Before settings on the WT11 chip can be changed, they must be directly sent to
it. This can be done by using a 3.3v USB to RS-232 serial converter\footnote{E.g. a
  breakout board with FTDI's FT232RL chip, which is widely available and can be
  used to update the firmware using the DFU protocol as well.
  \url{http://www.sparkfun.com/commerce/product_info.php?products_id=718}} and
connect it to the WT11 chips \texttt{RX} and \texttt{TX} pins which can be
located at the two solder points \texttt{JP1} directly underneth the WT11 chip
on the bottom side of the Arduino board. As \texttt{RX} is the receive line and
\texttt{TX} is the transmit, it is important to cross these two\footnote{Serial
  converter RX goes to WT11 TX and serial converter TX goes to WT11 RX} when
connecting the serial converter and the WT11 chip. No damage will happen if the
lines aren't crossed, but no communication will be able to take place.

There can be some timing issues if using an external power source while using
the serial convert, so it is highly recommended to use the serial converters
3.3v power supply feature.

The most common issues and solutions is

\begin{itemize}
\item If control echo has been enabled it will not be possible to program the
  Atmega chip as the bootloader will receive messages from the WT11 chip at
  bootup and thus fail when waiting for control characters. The solution to this
  is to disable control echo by sending the command \texttt{SET CONTROL ECHO 0}.

\item If the SPP (Serial Port Profile) has been disabled, no host can make a
  serial (rfcomm) connection and thus not make any serial communication (program
  the Atmega chip). The solution to this is to enable the SSP again by sending
  the following command \texttt{SET PROFILE SPP on} and then reset the WT11 chip
  by putting high on pin 7 for a short while or sending the command
  \texttt{RESET}.

\item If bluetooth connection is restored, the serial converter is still
  connected and any attempt to program the Atmega chip fail. Solution to this is
  that the serial converter must not be connected to the Arduino board while
  trying to program the Atmega chip. 

  In fact the serial converter interferes with the signals whether it is
  connected to the WT11 chip or Atmega Chip (digital pins 0 and 1). This results
  in communication only goes between the serial converter and the chip it is
  connected to. So whenever communication between the Atmega chip and the WT11
  chip is desired, the serial converter must be disconnected.
\end{itemize}

\subsection{iWRAP interface}

By default the WT11 chip uses the iWRAP firmware which enables the user to
access Bluetooth functionality with simple ASCII commands sent by a serial
interface. The Arduino BT board is shipped with the iWRAP firmware version 2.2.0
as default. If the Arduino BT board is used with a host that takes care of the
binding then there is properly no need for changing any of the WT11 chips
settings. But if the Arduino BT board is the one who needs to do the binding
with another Bluetooth device then it is necessary to change the settings and
therefor also shift into command mode. A thorough description of the different
iWRAP settings and commands can be seen in the iWRAP 2.2.0 User
Guide\cite{iWRAP220UG}.


\subsubsection{iWRAP modes}

iWRAP can be in three different modes: command,data and mux mode (multiplexing
mode).

Command and data mode are the default behaviour. Before sending any commands to
the iWRAP interface it must be in command mode. The iWRAP interface is always in
command mode when there is no active connections. When a connection is made
iWRAP automatically switches to data mode on this connection.  The mode can be
switched back to command mode by waiting at least one second, sending the
sequence \texttt{esc esc esc} and wait at least one second (\texttt{esc} is the
defined escape character\footnote{The escape character is defined by the iWRAP
  command \texttt{SET CONTROL ESCAPE}}). When in command mode the \texttt{LIST}
command will list all active connections and \texttt{SELECT} \textit{link\_id}
command will switch to data mode on the specified connection. Command/data mode
has the advantage of being easy and fairly intuitive when operating one a small
amount of active connections (preferably only one connection) but when multiple
connections is used the mode switching becomes quite a bottleneck as iWRAP needs
to be in data mode on the desired connection to receiving data and if it is in
command mode or data mode on another connection the data is stored in a buffer
and thus could potentially be lost if the buffer overflows before the connection
is selected.

This can however be solved by using multiplexing mode. In multiplexing mode data
and command mode is melted into one mode and it uses a special protocol which
doesn't accept normal iWRAP ASCII commands. Instead the multiplexing protocol is
a ASCII list of space separated hex values that contains some control segments
which defines whether the data part is a control (iWRAP command) sequence or
which connection the data sequence should be sent to or is received
from. \Fref{tab:multiplexing_protocol} illustrates the multiplexing frame
format.

\begin{table}[h!]
  \centering
  \textsf{
    \begin{tabular}{|l|l|l|l|}
      \hline
      \textbf{Length:} & \textbf{Name:} & \textbf{Description:} & \textbf{Value:} \\ \hline
      8 bits & SOF & Start of Frame & \texttt{0xBF} \\ \hline
      8 bits & LINK & Link ID & \texttt{0x00}--\texttt{0x08} or \texttt{0xFF} for
      control commands \\ \hline
      6 bits & FLAGS & Frame Flags & \texttt{0x00} \\ \hline
      10 bits & LENGTH & Size of data field in bytes & - \\ \hline
      0-800 bits & DATA & Data & - \\ \hline 
      8 bits & nLINK & LINK \texttt{xor} \texttt{0xFF} & - \\ \hline 
    \end{tabular}
  }
  \caption{Multiplexing frame format as described in Table 4 of the iWRAP 2.2.0 User
    Guide}
  \label{tab:multiplexing_protocol}

\end{table}

When multiplexing mode is enabled\footnote{To enable multiplexing mode send the
  iWRAP command \texttt{SET CONTROL MUX 1}}, it can be disable by the following
sequence \texttt{BF FF 00 11 53 45 54 20 43 4f 4e 54 52 4f 4c 20 4d 55 58 20 30
  00} which should be send as its ASCII representation without spaces. A python
script that demonstrates this can be seen in \fref{sec:python-demux-script}.

The sequence breaks down to the following

\begin{center}
  \begin{tabular}{|l|p{300pt}|}
    \hline 
    \textbf{Name:} & \textbf{Description:} \\ \hline
    \textsf{SOF} & Is always \texttt{0xBF} \\ \hline
    \textsf{LINK} & Is \texttt{0xFF} as it is a control command \\ \hline
    \textsf{FLAGS} & Is always \texttt{0x00} \\ \hline
    \textsf{LENGTH} & Is \texttt{11} (length of data is 17 characters) \\ \hline
    \textsf{DATA} & Is \texttt{53 45 54 20 43 4F 4E 54 52 4F 4C 20 4D 55 58 20
      30} which is the hex representation of \texttt{SET CONTROL MUX 0} \\ \hline
    \textsf{nLINK} & is \texttt{0x00} as \texttt{0xFF xor 0xFF = 0x00} \\ \hline
  \end{tabular}
\end{center}
 
iWRAP commands should not end with ``$\backslash$r'' or
``$\backslash$r$\backslash$n'' when used in a multiplexing frame.

The iWRAP 2.2.0 User Guide states that there can be used four simultaneous
connections in multiplexing mode, though iWRAP 3.0.0 User Guide\cite{iWRAP300UG}
states in section 6.20.3 on page 120 that 

\begin{quote}
  In MUX mode the processor of the module is highly utilised and on the edge of
  its performance. This may be seen as a instability of Bluetooth connections,
  especially if 3 or more connections are used or data rate is high.
\end{quote}

\noindent
and suggests to use \texttt{SNIFF} mode and optimise the bluetooth packet size
by using the MTU option in the \texttt{CALL} command to leave more time for the
processor to parse the multiplexing protocol. 

Section 3 of the iWRAP 2.2.0/3.0.0 User Guide covers the three iWRAP modes in
depth.


\subsubsection{Firmaware update}

Bluegiga Technologies support 2 ways of updating the firmware. A proprietary SPI
protocol that uses a SPI interface or a open DFU (Device Firmware Update)
protocol\footnote{The DFU protocol description can be retrieved by contacting
  the Bluegiga support team.} which uses a DFU interface over a UART or USB connection.

The downside of the SPI interface is that 

\begin{itemize}
\item it requires a special SPI cable which basically is a parallel to SPI cable
  converter.

\item The proprietary BlueSuite software supplied by Bluegiga Technologies used
  to update the firmware is only released for Windows\footnote{It has not been
    confirmed whether or not it works on Linux through Wine}.

\item It is necessary to have direct access to the WT11 chip's SPI interface.
\end{itemize}

Downside of DFU interface is that 

\begin{itemize}
\item it requires special version of the firmware which can be obtained by
  contacting the Bluegiga support team.

\item It is however not all firmware versions that can be update through the DFU
  interface\footnote{``... For example iWRAP 2.1.0 can not be updated to iWRAP
    2.2.0, since the DFU boot loader code has changed''
    (\url{http://techforum.bluegiga.com/faq_item?id=10377296} 17th of may at
    19:36)}.

\item It is necessary to have access to the WT11 UART or USB
  interface. This can however be done by uploading a program to the host
  processor through Bluetooth and make it do the firmware upgrade.
\end{itemize}

Bluegiga Technologies recommends to buy or build\cite{oik_chematic} a OIK
(OnBoard Installation Kit), but the Arduino community has posted an
alternative schematic\cite{oik_chematic_arduino}.

\fixme{this section needs restructuring.}
\fixme{this section is outdated. Firmware update has been done another way.}

\chapter{Problems in Flask}
We've detected a few Flask problems, that we think should be fixed.

\begin{itemize}
\item Pattern-matching isn't handled correctly. The following program
  is compiled as if the two first cases where overlapping (i.e. the
  second case would be ignored)
\begin{verbatim}
f (1, (1, x)) = 2
f (1, (2, x)) = 3
f (2, _) = 3
\end{verbatim}

\item Lack of type-classes in Red
\item In Red, negation with \texttt{negate} and \texttt{(-)} only works for
  integers. (Probably related to the lack of type-classes).
\end{itemize}

\chapter{Guide to electronics}

\fixme{Maybe a little refresher on electronics (e.g. how each
  component are drawn in a diagram, if we are going to use diagrams in
  the article). }

\chapter{Code snippets}

\section{Python demux script}
\label{sec:python-demux-script}

This is a python script that sends the iWRAP command \texttt{SET CONTROL MUX 0}
to disable multiplexing mode. This assumes that the breakout board is connected
to the WT11 chips serial communication pins and connected to the computer at
\textit{/dev/ttyUSB0}.

\begin{verbatim}
#!/usr/bin/python

# sets str to '\xbf\xff\x00\x11SET CONTROL MUX 0\x00'
str = 'BFFF001153455420434f4e54524f4c204d5558203000'.decode("hex")

f = open('/dev/ttyUSB0', 'w')
f.write(str)
f.close()
\end{verbatim}

\end{document}
