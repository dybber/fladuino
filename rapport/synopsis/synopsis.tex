\documentclass[a4paper,oneside, draft]{memoir}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[danish]{babel}

\usepackage{colortbl}  % Bruges til at farve celler, rækker mv. i tabeller
\usepackage{pdflscape} % Gør landscape-environmentet tilgængeligt
\usepackage{fixme}     % Indsæt "fixme" noter i drafts.


\renewcommand{\ttdefault}{pcr} % Bedre typewriter font
%\usepackage[sc]{mathpazo}     % Palatino font
\renewcommand{\rmdefault}{ugm} % Garamond
\usepackage[garamond]{mathdesign}

%\overfullrule=5pt
%\setsecnumdepth{part}
\setcounter{secnumdepth}{-1} % Sæt overskriftsnummereringsdybde. Disable = -1.


\title{Synopsis}

\author{Martin Dybdal (dybber@dybber.dk), \\
Jesper Reenberg (jesper.reenberg@gmail.com) \\ og
Troels Henriksen (athas@sigkill.dk)}

\date{\today}
\pagestyle{plain}



\begin{document}
\maketitle


% http://image.diku.dk/mediawiki/images/9/9d/Playerstagereport.pdf

\section{Titel}
"`Deklarativt programmeringssprog til robotstyring"'

\fixme{Bør ordet reaktiv ikke være indeholdt i vores projekt titel i stedet for
  deklarativt?}


\section{Problemformulering}
% hvordan eller ikke hvordan?
(Hvordan) kan man implementere et deklarativt programmeringssprog, som gør det
muligt at programmere robotter, i en syntaks der ligger tæt op ad en
specifikation?

\section{Uddybning}

Følgene vil problemformuleringen bliver uddybet i et motivations- og
implementationsafsnit.

\subsection{Motivation}
Når man specificerer hvad robotter skal gøre, angiver man det ofte som sætninger
der forklarer hvilke \textit{hændelser} de skal være opmærksomme på og hvordan
de skal \textit{reagere} når disse hændelser indtræffer. En uformel
specifikation af en strategi der følger væggene i et rektangulært rum, kunne
være "`Kør lige ud ind til du er 20 cm fra en væg. Drej derefter 90 grader mod
højre og start forfra med at køre lige ud"'. Her er der en åbenlys hændelse der
indtræffer "`20 cm fra en væg"' og en reaktion "`drej 90 grader mod højre og
fortsæt"'.

De mest anvendte sprog og biblioteker til programmering af robotter lægger op
til en programmeringsstil hvor man skal "`trække"' informationer ud fra sensorer
og lignende. Eksempelvis må man hele tiden sende forespørgsler til en
afstandsmåler for at høre om robotten er ved at køre ind i noget. Dette er i
modstrid med de normale specifikationer, hvor man som sagt taler om
\textit{hændelser} og \textit{reaktioner}. Vi vil derfor lave hændelses-baseret
sprog, hvor man kan lave en hændelse ("`mindre end 20 cm til væg"'), som
aktiverer en reaktion ("`drej 90 grader mod højre og fortsæt"') hver gang
hændelsen indtræffer (en specifik afstandsmåler rapporterer en afstand der er
mindre end 20 cm).

Fordelen ved den deklarative tilgang burde derfor være klar: der er kortere vej
fra specifikation til kørende kode.


\subsection{Implementation}
For at undgå at bruge en stor mængde tid på skrive en oversætter til vores
sprog, vælger vi at implementere det som et EDSL (Embedded Domain-Specific
Language) indbygget i Haskell. Sproget vil altså bestå af en række Haskell
operatorer og funktioner, som gør deklarativ robotprogrammering mulig. Vi mener
at Haskell har rigeligt med muligheder for at definere et EDSL der udtryksfuldt
nok, uden at skulle f.eks. udvide det via template
metaprogramming\footnote{Dette kunne gøres med Template Haskell eller
  Quasiquotation-biblioteket.}.

Vi vil også gerne undgå at skrive lav-niveau kode for at kommunikere med en helt
specifik robot, da vi har en forventning om at det måske vil kræve en større
mængde kode og fordi der findes biblioteker hvor andre allerede har drivere til
en række robotter. Vi har derfor valgt at bygge vores sprog oven på
Player/Stage-biblioteket, der er udviklet specielt til robotprogrammering. Det
er meget anvendt \footnote{http://playerstage.sourceforge.net/wiki/PlayerUsers
  -- faktisk eksisterer denne URL ikke pt. men forhåbentligt står der en masse
  brugere, når den en gang kommer op.} og har to store fordele: der findes både
2D og 3D simulatorer og der er drivere til en lang række robotter og
sensorer. Bl.a. har to DIKU studerende udviklet drivere der gør det muligt at
bruge Player/Stage til at programmere DIKU's Scorpion-robotter
\footnote{"`Player driver implementation for ERSP"'
  (http://image.diku.dk/mediawiki/images/9/9d/Playerstagereport.pdf)}.


\section{Afgrænsninger}
\begin{enumerate}

\item Vi vil ikke oversætte til et primitivt sprog, for at få det til at køre på
  indlejrede platforme. Ideen er i stedet at programmet kører på en almindelig
  PC, hvorfra styringssignaler sendes til og fra robotten igennem et datakabel
  (f.eks. USB)

% Jakob Grue mente at nedenstående krav ikke er nødvendigt: vi vil ikke
% opleve problemer med at overholde alle fornuftige real--time krav.
% Alternativt kan vi vel formulere noget om at programmeringssproget
% ikke vil indeholde måder at angive real--time kravene.
%
%\item Vi forventer ikke at programmer skrevet i vores
%  programmeringssprog skal overholde realtime--krav. Dette betyder at
%  effektiviteten af implementationen ikke er en væsentlig del af opgaven.
\item Vi har ikke tænkt os at skrive noget større program i vores sprog. Vi har
  i stedet tænkt at vise udtryksmulighederne, via mindre eksempelprogrammer. (At
  skrive et større program vil dog være en mulig udvidelse af projektet, hvis vi
  får tid)

\item Ideelt set vil vi gerne kunne afprøve vores sprog på en fysisk robot, men
  da vi ikke er sikker på muligheden for at få fat i en sådan, vil denne
  afprøvning ikke være en del af opgaven. Det bemærkes igen at Player/Stage
  indeholder udemærkede simulatorer, som vi kan bruge under afprøvningen.

\end{enumerate}

\section{Arbejdsopgaver}

\fixme{Revider tidsmålene så de passer ind med 3 mennesker. Definer også faste
  datoer og visualiser hvordan de overlapper hinanden.}
Projektet løber fra uge 6 til og med uge 24.

\begin{enumerate}

\item Undersøge allerede eksisterende robotprogrammeringssprog og almindelige
  arbejdsopgaver indenfor robotprogrammering.

\item Forudgående undersøgelser (1 uge).
  
  \begin{itemize}
    
  \item Find ud af om vi kan få lov at låne Scorpion-robotterne og hvor
    vidt Player/Stage driveren til dem er funktionel nok til det er sjovt.
    
  \item Alternativt: skaf en anden robot (Roomba?)
    
  \end{itemize}

\item Lave Haskell-bindings til Player/Stage (FFI til C-biblioteket libplayerc)
  (1 uge).
  \label{item:opgaver:ffi-bindings}

\item Definere syntaks og semantik for vores EDSL (3 uger).
  \label{item:opgaver:definer-syntaks}

\item Implementere det definerede EDSL vha. de i \ref{item:opgaver:ffi-bindings}
  implementerede Haskell-bindings til Player/Stage og den i
  \ref{item:opgaver:definer-syntaks} definerede syntaks og semantik (2 uger).

\item Lav eksempler på hvordan sproget bruges i praksis. (2 uger)
  \label{item:opgaver:lav-eksempler}

  \begin{enumerate}
  
  \item Sammenlign eksempelprogrammerne med tilsvarende skrevet direkte til
    Player/Stage i C, C++ eller Python Robotics.
  
  \end{enumerate}
  
  
\item Brug de i \ref{item:opgaver:lav-eksempler} lavede eksempler til at teste
  om implementationen opfylder den i \ref{item:opgaver:definer-syntaks}
  definerede syntaks (1 uge).
  
\item Færdiggøre rapport.(2 uger)
  
\item Afpudsning af rapport. (3 dage)
  
\item Buffer og tid til at arbejde på mulige udvidelser af projektet. (uge 20-24)
\end{enumerate}

\section{Specifikke Læringsmål}

Projektet skal gøre de studerende i stand til at:

\begin{enumerate}

\item Forklare hvad FRP er, samt forklare fordele og ulemper ved at bruge FRP.

\item Udvikle struktureret, fleksibelt og veldokumenteret programmel i Haskell

% \item Demonstrere hvordan et domæne specifikt sprog (DSL) til at skrive 
% kontrol programmer til indlejret systemer i FRP stil, kan indlejres i et 
% moderne funktionelt sprog som F# eller Haskell, dvs som et DSEL. 
% Således at det er muligt at prototype og simulere kontrolprogrammerne i 
% værtssproget, samt at generer kode der kan køre på en rigtig indlejeret 
% plat form, som fx arduino.

\item Foretage en systematisk evaluering af et sådant DSEL. \fixme{"et
    sådant DSEL"', hvilket?}

\end{enumerate}


\section{Mulige udvidelser af projektet ("`nice to have"')}
\begin{enumerate}

\item Udvidelse af sproget til at skrive programmer til flere robotter (flocking).

\item Skriv et større eksempelprogram i vores programmeringssprog.

\item Lav en formel semantik for sproget

\end{enumerate}

% \begin{landscape}
% \begin{center}

%   \definecolor{uofsgreen}{rgb}{.125,.5,.25}
%   \definecolor{natvidgreen}{rgb}{.196,.364,.239}
%   \definecolor{lightgrey}{rgb}{.6,.6,.6}
%   \definecolor{grey}{rgb}{.4,.4,.4}


% \begin{tabular}{ccccccccccccccccccc}
% \multicolumn{19}{c}{Uge nr.} \\
% 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 & 18 &
% 19 & 20 & 21 & 22 & 23 & 24\\ \hline
% \multicolumn{3}{c}{\cellcolor{black} } & \multicolumn{8}{l}{Synopsis} \\  
% & & \multicolumn{2}{c}{\cellcolor{red}} & \multicolumn{8}{l}{Haskell-bindings} \\  
%  & & & \multicolumn{3}{c}{\cellcolor{lightgrey}} &

%  \multicolumn{8}{l}{Rapport: Indledning} \\
%  & & & & & \multicolumn{6}{c}{\cellcolor{grey}} &
%  \multicolumn{8}{l}{Rapport: Analyse-del} \\
% & & & & & & \multicolumn{6}{c}{\cellcolor{blue}} &
%  \multicolumn{7}{l}{Implementation} \\
%  & & & & & & &  \multicolumn{6}{c}{\cellcolor{magenta}} &
%  \multicolumn{6}{l}{Definition af syntaks} \\
% \multicolumn{10}{r}{Udvikling af eksempelprogrammer} & \multicolumn{5}{c}{\cellcolor{cyan}}
%  \\
% \multicolumn{15}{r}{Afpudsning af rapport} & \cellcolor{yellow}
%  \\
% \multicolumn{16}{r}{Buffer-uger} & \multicolumn{3}{c}{\cellcolor{green}} \\  
% \end{tabular}
% \end{center}
% \end{landscape}


\begin{landscape}
\begin{center}

  \definecolor{uofsgreen}{rgb}{.125,.5,.25}
  \definecolor{natvidgreen}{rgb}{.196,.364,.239}
  \definecolor{lightgrey}{rgb}{.6,.6,.6}
  \definecolor{grey}{rgb}{.4,.4,.4}


\begin{tabular}{ccccccccccccccccccc}
\multicolumn{19}{c}{Uge nr.} \\
6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 & 18 &
19 & 20 & 21 & 22 & 23 & 24\\ \hline \hline
\multicolumn{3}{c}{\cellcolor{black} \color{white}  Synopsis } \\  
& & \multicolumn{2}{c}{\cellcolor{cyan} \color{white}} & \multicolumn{6}{l}{Haskell-bindings} \\
& & & \multicolumn{3}{c}{\cellcolor{lightgrey} \color{white} } & \multicolumn{6}{l}{Rapport: Indledning} \\
& & & & & \multicolumn{6}{c}{\cellcolor{grey} \color{white} Rapport: Analyse-del} \\
& & & & & &  \multicolumn{6}{c}{\cellcolor{magenta} \color{white} Definition af
  syntaks} \\
& & & & & & & \multicolumn{6}{c}{\cellcolor{blue} \color{white} Implementation} \\
\multicolumn{10}{r}{} & \multicolumn{5}{c}{\cellcolor{red} Udvikling
  af eksempler}
 \\
\multicolumn{14}{r}{Rapport: Afpudsning} & \multicolumn{2}{c}{\cellcolor{yellow}}
 \\
\multicolumn{16}{r}{} & \multicolumn{3}{c}{\cellcolor{green} Buffer-uger} \\  
\end{tabular}
\end{center}
\end{landscape}



\end{document}
